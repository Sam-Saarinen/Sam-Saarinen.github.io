[{"prompt":"Whenever x1 holds, it cannot hold again until x2 does","rationale":"I think this is interesting because the 'cannot hold again until x2 does' is not quite the same as saying !x1 U x2 since that requires that x2 does in fact hold at some point. To write a correct formula, one has to think of this and allow for the possibility of G(!x2)","answers":[{"studentID":"p81246jCdnf8jPP6ckaxgaA9ceB3","answer":"F(x1) => (X(x1)* =>  X(x2)-)","explanation":"My answer uses an implication that establishes that if x1 holds, then if there is some time step in the future where x1 holds again then it is implied that x2 must have held in those previous statements prior to the time step where x1 held for the second time."},{"studentID":"qsvPOzEQ1NeTrWs1iQmcqVOTHOJ3","answer":"G(x1=> (F(x2=>x1))","explanation":"This one was tricky and I don't think my answer is right. I believe that if G(x1 => states that whenever x1 is true, (F(x2=>x1)) states that whenever x2 becomes true, x1 must become true. "},{"studentID":"AJhRpKsvXyRzhbZwJMshU1xBreG3","answer":null,"explanation":null},{"studentID":"yqAbP1hwmpWXnQQRHWGW0uOlRPB3","answer":"x1 => (!x1 U x2)","explanation":"x1 is false until x2, whenever x1 is true"},{"studentID":"xnwt9vlgrKQMCMF8UkHGCLYNOxw2","answer":"▢(x1 -> ○(¬x1)) U (x2 -> x1)","explanation":"I am basing my symbols from: http://www.cds.caltech.edu/~murray/courses/afrl-sp12/L3_ltl-24Apr12.pdf, and http://cs.brown.edu/courses/cs195y/2020/pages/pdf/LTL.pdf. From what I understand, ○ represents next state. Therefore, I stated that whenever(▢) x1 holds,  it implies that in the next state, x1 would not hold. \"U\" indicates until. Hence, I continue the statement with \"U\" saying that \"x2->x1\". In other words, I state that when x2 holds, x1 can also hold."},{"studentID":"DziAzopaJDV4Nz8ugZowMZyrf2l2","answer":"G(x1->X(!x1Ux2))","explanation":"always, if x1 holds, in the next state, it cannot hold until x2 holds "},{"studentID":"FJ1gcCB1SMXfbX4ehcXzcYHcs7l1","answer":"G(x1 => X(~x1 U x2))","explanation":"This is a condition that should always hold (G). It is a condition on x1 being true (hence \"x1 =>\"), and we want it so that ~x1 holds until x2 holds after that (hence (~x1 U x2)). We include the X because we want the until condition to only hold after the current state, since x1 is true in the current state."},{"studentID":"Iwmu1MjrCwcLIRbtZ2likbd2krr2","answer":"G(x1->(¬x1)Ux2)","explanation":"If sometimes x1 holds, then x1 would be fixed to be false until x2 occurs to be true. "},{"studentID":"uhSgQJpSx7dbcXRJqnQpLJPHK8s1","answer":"x1:= true -> x1:=false U x2:=true","explanation":"I used implies because it is an if-then statement, and since U represents something holds up until something else (from online syntax resource) I used that to show \"until x2 does\" "},{"studentID":"k6kvJj5VCUPWLj2ppeOMNVBQzeJ2","answer":"G(x1 -> X(!x1 U x2))","explanation":"I am using G to say this always holds. I am using X to get the trace starting at the next step and I am using U to say that x1 will be false until x2 is true."},{"studentID":"EbUb3Z6acpajSNs7t62nSh5UpGi2","answer":"x1 => (!x1 U x2)","explanation":"x1 holding implies that it will not hold again until x2 holds. I translated the whenever into an if via implies."},{"studentID":"OorJbOFV8odzg7bElwAX7qMXKeu2","answer":"x1, G(X(not x1)) U x2","explanation":"I tried to say that if x1 holds, then always the next state x1 will be false until x2 is true."},{"studentID":"T4nr7nKQtkexYyVAi3NwCSqKC5n2","answer":"G(x1 -> G(X(not x1) U X(x2))))","explanation":"it's always true that if x1 is true, x1 can't be true in subsequent states until x2 is"},{"studentID":"kOYh8lB1WQhEgx5Pte67U4XSnE93","answer":"x1 implies F(x1) iff x2","explanation":"We know that x1 might hold, which means it must imply the condition for it to occur again. Basically, x1 will eventually hold in the future only if x2 also holds. One piece of nuance that my statement might not totally account for is that I'm not sure with the syntax that i'm using, if it's saying that x2 will be true in the same time that x1 was originally true, or some time in the future where x2 is true. I'm afraid if it's the former, my statement might not be correct."},{"studentID":"YzyRkeE37AhpGTSNU8zVMBwEojl1","answer":"x1 -> (!x2 U x2) U x1","explanation":"when x1 is true, that implies that the next x1 is only true when x2 is true (U function for the second part)"},{"studentID":"n6X9W01WPlSOMef0b3WU2WBmqVC2","answer":"x1 -> G(¬x1) U x2","explanation":"\"unti\" := U"},{"studentID":"UJYax3ztBqcD2acHhEY8qP4lBhG3","answer":"G(x1 U X(!x1 W x2)","explanation":"Wikipedia lists a \"weak until\" operator that can be constructed from the existing ones to enforce that something must be true until a condition is met."},{"studentID":"7YpZ1Wx49VhhkqMHvH1TZC9HKEz1","answer":"G(not x1 v X((not x1) U x2))","explanation":"Inside the \"G\" is an implication, saying that if x1 holds then x1 cannot hold in the next state, and it will not hold until x2 holds."},{"studentID":"u5LtkhMrVVVNvSHlNyzDQIjuWQl2","answer":"(!x1 U x2) or G(!x1 and !x2)","explanation":"Two cases should be considered.\n1. x2 does hold at some point. According to the question,  x1 cannot hold until then.\n2. x2 never holds. Therefore, x1 also cannot hold."},{"studentID":"zKquIv2iqOPUbju84kD6x2oqxQC3","answer":null,"explanation":null},{"studentID":"SXuWPt2DVGRMnfN2ELdVux2pv9j2","answer":"G(x1 => X(!x1 U x2))","explanation":"Whenever x1 = G(x1 => ...), it cannot hold again [starting from the next step] = X(!x1 ...), until x2 = U x2"},{"studentID":"2uAPcLiTl6S6lkVxb49jwVczlXD2","answer":null,"explanation":null},{"studentID":"CUpKAZiiOrMlB7VEhcBrcxBDduN2","answer":"x1 -> X(!x1) U x2","explanation":"x1 being true implies that the next state of x1 is false (X(!x1)) until (U) x2 is true"},{"studentID":"eaIqaTs5sLTe88iSf2SdfYFDqPs2","answer":null,"explanation":null},{"studentID":"lRaLOybCkkdkd88UUN9jWGgL9fB3","answer":"G(x1 -> X((!x1 U x2) v G(!x1 and !x2)))","explanation":"I wrote this. Whenever x1 holds 'G(x1 ->', in the future it is either the case that x1 is false until x2 is true (and x2 does in fact hold at some point) or that all states make x1 and x2 false, in which case the U would not be satisfied but the English would be"},{"studentID":"zd3DqHgbJ4chMqRezEqT5W4giFe2","answer":null,"explanation":null},{"studentID":"da61uKxwS4RS8uLw9e5aDhx9AAG2","answer":"x1 ->  (NOT x1) U x2","explanation":"If x1 is true, that implies that NOT x1 should be true at least until x2 is true (U)"},{"studentID":"0HC3dpmLyKeoD74DguNF8DNwqrj1","answer":"(F(x1) and x1) => x2 U x1","explanation":"x1 holding true and eventually x1 holding true again implies that there exists an event where x2 occurred before x1"},{"studentID":"j2h7kE6TUTe8mOHJ8n2gWkGvi922","answer":null,"explanation":null},{"studentID":"FedMWmwEd7W3C68gTqm66aRiqns2","answer":"G(F(x2 -> x1))","explanation":"x1 will eventually hold when x2 holds, always will hold"},{"studentID":"AAzmbLYzxbcuw8WEJsNweNOfr542","answer":"G(x1 implies (NOT x1 U x2))","explanation":"Whenever x1 holds, [...] is equivalent to G(x1 implies [...]).\nit cannot hold again until x2 is Not x1 until x2."},{"studentID":"Ao8FhZPEPeV6WdP0CYNeEiGGwP52","answer":null,"explanation":null}]},{"prompt":"x1 is always true until x2 is true or x3 is true, and x3 will be true eventually.","rationale":"I think it's interesting because you need x2 or x3 to be true in order to make x1 change to false. However, while x3 is guaranteed to eventually be true, x2 is not. So, you're guaranteed that x1 will switch to false eventually because of x3, but it's also possible it could change beforehand because of x2.","answers":[{"studentID":"AxWttnGXbFOGMdMAoOcSQHoPFuB2","answer":"(x1 U x2 or x3) and F(x3)","explanation":"The until is captured by U, with the G and F being applied to both sides of the U statement according to the outline. x3 being eventually true is captured by F."}]},{"prompt":"Parents with high education will always have children who would also pursue education.","rationale":"This stereotype has been going around a lot. I have heard stories of many people about how their parents are not as highly-educated but are very successful and sent their children to great places for education. I am wondering if this is true in the opposite way and how it can be modelled using LTL as a timeline of a person's life from generation to generation. ","answers":[{"studentID":"79DF8m2XmUOKjV8Ob9evefRWNHw1","answer":"x1 -> G(x2)","explanation":"x1 is parents with high education \nx2 children with high education"},{"studentID":"ehCdx7swHhPf72JGATgbRZ2e7rs1","answer":"G(x1) -> G(x2)","explanation":"G means always.x1 means parents with high education and x2 means children who would also pursue education."},{"studentID":"06qfdQBcQyMQkXqkqBmyYkv99ns2","answer":"Let x1 = parents have higher education, x2 = said parents have children who would also pursue education\n\nG(x1 => x2)","explanation":"G(x1 => x2) means that x1 (parents having higher education) will always imply x2 (they have children who would also pursue education)"}]},{"prompt":"Whenever x1 is true, x1 is false and x2 is true in the state after; whenever x2 is true, x1 is false and x1 is true in the state after","rationale":"tests the relationship between two variables and successor states","answers":[{"studentID":"1PfpKQ5FbSaFVpjLU0zEvi2Vsni2","answer":"G((X1 and X(not x1 and x2)) or (X2 and X(x1 and not x2)))","explanation":"The G means that it is always the case. The argument of G means that it is always the case that either of two things happen: x1 is true and (not x1 and x2) is true in the next state, or x2 is true and (x1 and not x2) is true in the next state"},{"studentID":"7YpZ1Wx49VhhkqMHvH1TZC9HKEz1","answer":"G((not x1) v  X(x2 and not x1)) ^ G((not x2) v X(x1 and not x1))","explanation":"I think this one is a contradiction in the second half of the conjunction depending on how you interpret the location of the parentheses. However, I believe that in LTL a contradiction is still a legal formula, so I just translated it as literally as possible using \"G\" plus implication to mean \"whenever\" and using \"X\" to represent something being true in the next state."},{"studentID":"3C5iQZrpLIPHa4l0KSVRUYUAeYn2","answer":"(~x1 v (X(~x1)^X(x2))) ^(~x2)","explanation":"I couldn't think how to write 'in the state after' so I am using X(var) to mean that.\n(x1 -> (X(~x1)^X(x2))) ^(x2 -> (X(~x1)^X(x1)))\nWe then replace implies p->q with logically equivalent  ~p v q\n(~x1 v (X(~x1)^X(x2))) ^(~x2 v (X(~x1)^X(x1)))\nbut (X(~x1)^X(x1)) is a contradiction so we have (~x2 v F) on the right hand side, which we can simplify to ~x2\nso in total we have \n(~x1 v (X(~x1)^X(x2))) ^(~x2)"},{"studentID":"Wy5fyfEMa6cPDN3JzFAmXgbXvaw2","answer":"G(x1 -> X((!x1) and x2)) and G(x2 -> X((!x2) and x1))","explanation":"\" whenever x2 is true, x1 is false and x1 is true in the state after\" interpreted as \" whenever x2 is true, x*2* is false and x1 is true in the state after\""},{"studentID":"yqAbP1hwmpWXnQQRHWGW0uOlRPB3","answer":"x1 => X(!x1 and x2) and x2 => (!x1 and X(x1))","explanation":"There may be an error here since it is unclear which conditions are included in \"in the state after\". Regardless, if x1 is true, it implies in the next state (!x1 and x2).  If x2 is true, x1 is false, then x2 is true in the next state (!x1 and X(x1))"},{"studentID":"DziAzopaJDV4Nz8ugZowMZyrf2l2","answer":"G(x1 -> X(!x1 ∧ x2)) ∧ G(x2 -> X(x1 ∧ x2))","explanation":"always, if x1 is true, next is that x1 is false and x2 is true; if x2 is true, next is that x1 is false and x2 is true. I think there's error in description, it should be \" x1 is false and x2 is true in the state after\""},{"studentID":"QNFbaiaIhcRfRQoHtE9QvXtkhxf1","answer":"x1 |= X!x1 and Xx2\nx2 |= X!x1 ","explanation":"|= is the satisfiability relation, therefore the first conditions means that x1 is true if in the next step x1 is false and x2 is true, and the second means that x2 is true when x1 is false is in the next step."},{"studentID":"mhnr5IV9YdS7voOl3kwhPQJ3bcn1","answer":"(x1 => X(!x1 and x2)) U (x2 => (!x1 and X(x1))) ","explanation":"x1 implies the future state of itself and x2, and x2 implies the future and current state of x1"},{"studentID":"XXDQ67q4UiSR2kFxVzhaxL1hRZC3","answer":"G(x1=>¬X(x1) ∧X(x2))\nG(x2=>¬x1 ∧X(x1))","explanation":""},{"studentID":"OorJbOFV8odzg7bElwAX7qMXKeu2","answer":"(x1, X(not x1, x2)), (x2, X(not x1, X(x1)))","explanation":"I tried to nest operations. If x1 is true in current time, then x1 is not true and x2 is true in the state after; if x2 is true, x1 is false in the state after, and x1 is true in the state after that."},{"studentID":"n6X9W01WPlSOMef0b3WU2WBmqVC2","answer":"False","explanation":"x1 cannot be both true and false in the same state"},{"studentID":"9FWl8IytHMMyyETmCpMUJijdoEj2","answer":"x1 -> X(!x1 and x2) and x2 -> !x1 and X(x1)","explanation":"If x1, then in the next state x1 is false and x2 is true. And if x2, then x1 is false in the same state and in the next state x1 is true."}]},{"prompt":"Considering x1 and x2 as two threads both attempting to add lock on a variable.\ndescribe the rule that \"No more than one thread can have that lock\". \nTake true as success on locking and false as failure.","rationale":"It uses LTL to simulate an essential rule in synchronization. ","answers":[{"studentID":"j2h7kE6TUTe8mOHJ8n2gWkGvi922","answer":"G( x1->!x2 and x2->!x1)","explanation":"G means that this always holds, x1->!x2 means that if x1 is true then x2 is false and x2->!x1 means that if x2 is true then x1 is false"},{"studentID":"SXuWPt2DVGRMnfN2ELdVux2pv9j2","answer":"G(!x1 or !x2)","explanation":"No more than one thread can have the lock, so always (G), one doesn't have it (!x1) or the other (!x2)"},{"studentID":"n6X9W01WPlSOMef0b3WU2WBmqVC2","answer":"G(¬(x1 ^ x2))","explanation":"x1 and x2 cannot be true at the same state"},{"studentID":"9FWl8IytHMMyyETmCpMUJijdoEj2","answer":null,"explanation":null},{"studentID":"oHfP2KoEE8PHFh9JpFBlrT9FonJ2","answer":"G((x1 U x2) and (x2 U x1))","explanation":"It always true that x1 will be followed by x2 and x2 will be followed by x2"},{"studentID":"u5LtkhMrVVVNvSHlNyzDQIjuWQl2","answer":"G(!(x1 and x2))","explanation":""},{"studentID":"phrbqZWVjcRh1ZJhWZHdh1yEhMZ2","answer":"G((x1 and !x2) or (!x1 and x2) or (!x1 and !x2))","explanation":"This simply excludes all states where x1 and x2 would be true at the same time"},{"studentID":"g189tDKZqyfaI2GiXyXWcUWilJB2","answer":"G ~(x1 && x2)","explanation":"We simply state that for all states, x1 and x2 cannot both be true (i.e. x1 and x2 cannot both have the lock)."},{"studentID":"1utNHrKBy7T4nb34YbOeaMGFzxl1","answer":"(x1 AND (!x2)) OR (x2 AND (!x1))","explanation":"A thread can be successful on locking only when the other thread has not locked the variable."},{"studentID":"UKl2qkKWlKO6BQ9PwxsbdegpkDV2","answer":"w ⊨ ¬F(x1 ∧ x2)","explanation":"We want it never to be true that more than 1 thread to hold this lock. This means don't want there to ever be a point where x1 and x2 both are satisfied. This means we want it to not be true that there eventually is a state where x1 ∧ x2 is true. F(x1 ∧ x2) means that there is some i such that w ⊨ (x1 ∧ x2), so we want F(x1 ∧ x2) to not be true, which means we have w ⊨ ¬F(x1 ∧ x2)."},{"studentID":"YZmWKZlgaZOrzGYNRp4TUVv5pZ13","answer":null,"explanation":null},{"studentID":"zKquIv2iqOPUbju84kD6x2oqxQC3","answer":"G(x1=>!x2 and x2=>x1)","explanation":"It always holds that if x1 is true x2 is false and if x2 is true x1 is false."},{"studentID":"Olm3iZ1G75hC3g8kxg51POXFM402","answer":"(x1 & !x2) | (!x1 & x2)","explanation":"only one can have the lock"},{"studentID":"xnwt9vlgrKQMCMF8UkHGCLYNOxw2","answer":null,"explanation":null},{"studentID":"LAeoyaF0twbF0V1g5eQ2GEPsxJE2","answer":"G(~x1 \\/ ~x2)","explanation":"It is always the case that either x1 or x2 does not have the lock."},{"studentID":"Ao8FhZPEPeV6WdP0CYNeEiGGwP52","answer":"G(¬(x1 ^ x2))","explanation":"This says it is always the case that x1 and x2 aren't both true in the same state"},{"studentID":"VXpluGJOfOUe37IfyjNfFz3GymV2","answer":"G(x1 -> X!x2 AND x2 -> X!x1)","explanation":""},{"studentID":"kOYh8lB1WQhEgx5Pte67U4XSnE93","answer":"G(x1->!x2 U !x1 -> (x2 or !x2))","explanation":"The statement is described that this condition, only x1 can be true, or x2 at a time, can be true.. So that means that if x1 is true, this implies that x2 is false. And this will be true until x1 becomes false."},{"studentID":"CUpKAZiiOrMlB7VEhcBrcxBDduN2","answer":"G((x1 and !x2) or (!x1 and x2))","explanation":"Always (G), only one of x1 and x2 are true."},{"studentID":"eaIqaTs5sLTe88iSf2SdfYFDqPs2","answer":"G((x1 and !x2) or (!x1 and x2) or (!x1 and !x2))","explanation":""},{"studentID":"qsvPOzEQ1NeTrWs1iQmcqVOTHOJ3","answer":"G(!x1 or !x2)","explanation":"!x1 or !x2 states that only x1 or x2 must be true at the same time. "},{"studentID":"Q6pogKCIaSh3uEueQnutSSKaDw33","answer":"G((x1 /\\ ~x2) \\/ (~x1 /\\ x2))","explanation":"It is always the case that either x1 or x2 is successful, but not both"}]},{"prompt":"x2 will always only become true if x1 is exclusively false until it is true, where x only flips values once.","rationale":"A fun little blend of conditionals, semantic parsing (on the human end, with the placement of the \"always\") and a fancy little until statement","answers":[{"studentID":"DfrktEsV96QCmKYSnC1SkAZ92Jm1","answer":null,"explanation":null},{"studentID":"OorJbOFV8odzg7bElwAX7qMXKeu2","answer":null,"explanation":null}]},{"prompt":"For a while, it is never the case that x1 is true and x2 is false at the same time, but after a certain point, x2 will eventually always be true.","rationale":"I considered the formula interesting because it contains a variety of operations and involves nested F's and G's.","answers":[{"studentID":"kd663bJTz0hO7SfexfzikeYZgj53","answer":"F x2\nX (~(x1 /\\ x2)","explanation":"not sure how to say 'for a while' "},{"studentID":"yLK6W8nyVrMUkNMyxFYLNsJdaPt2","answer":"(x1 and !x2) U F(G(x2))","explanation":"\"For a while\" and \"after a certain point\" made it seem like this x1 was true and x2 was false until something happened, which is why I put them on the left side of the U symbol. Since after the certain point, it will eventually will always hold that x2 is true, I put this on the right side of the U and put the expression inside of F and then a G because F means that it will eventually occur and G means that it will always occur. "},{"studentID":"DfrktEsV96QCmKYSnC1SkAZ92Jm1","answer":"~(x1 and ~x2) U G(x2)","explanation":"not the first condition until the second"},{"studentID":"YZmWKZlgaZOrzGYNRp4TUVv5pZ13","answer":"G(not(x1 and (not(x2))) U F((G(x2)))","explanation":"the binary operator \"U\" (until) expresses the idea that the LHS is true until the RHS is true. So first, it is always the case that x1 and x2 cannot be true at the same time, UNTIL, eventually (F), it is always true that x2 is true. "},{"studentID":"FK5jY3NfsvSIHK38KFpV6g8dFak1","answer":"~(x1^~x2)U(x1^~x2) ^ F(x1^~x2) ^  FGx2","explanation":"after a certain point, x2 will eventually always be true. FGx2\nFor a while, it is never the case that x1 is true and x2 is false at the same time => there is a time where ~(x1^~x2) true for all that time\n=> F(x1^~x2) (the condition have to be violated in the future) ^ ~(x1^~x2)U(x1^~x2)  (before that ~(x1^~x2) must strictly hold)"},{"studentID":"rsp3YalY4iYInzJzXy67djOCMdz2","answer":"G(!(x1 and !x2) and (F(x2)))","explanation":"Globally, it is never the case that (x1 is true and x2 is false) and eventually x2 holds true"},{"studentID":"Z8I0Gua8DxZT3Lr3BGcIfZxlivI2","answer":"( !(F(x2)) -> (x1 and !x2)) and G(F(x2))","explanation":"This basically says that x2 is not eventually true it implies that it is not the case that x1 is true and x2 is false at the same time, but AND that x2 will eventually always be true. "},{"studentID":"n6X9W01WPlSOMef0b3WU2WBmqVC2","answer":null,"explanation":null},{"studentID":"5oLl7ZPijNYyMSwp55PwKSehzRq1","answer":"(G(~(x1 and ~x2))) U (G(x2))","explanation":"Up until a certain point it should always be the case that (x1 and ~x2) is false and then after that point x2 should always be true. The U represents that up to some point the first half is true and then after that point the second part is true."},{"studentID":"g189tDKZqyfaI2GiXyXWcUWilJB2","answer":"~(x1 && ~x2) U (F G x2)","explanation":"We use the until operator U to divide the trace into two sets. The first expression, which is true for all states up to some state i, simply requires that x1 cannot be true when x2 is false. The second expression, which holds for the trace after state i, states exactly what is given: eventually (F) x2 will be true for all subsequent states (G)."},{"studentID":"mkSbSzp0rUQ30XSeUq1F4HqG0S82","answer":"!(x1 && !x2), F(x2)","explanation":"My answer is comprised of two parts, one specifying that x1 true and x2 false will never happen, and one that x2 will be finally true"},{"studentID":"QNFbaiaIhcRfRQoHtE9QvXtkhxf1","answer":"F(F(x1 and !x2) -> F(G(x2)))","explanation":"F means eventually, so the above is saying that eventually x1 will be true and x2 will be false, and when thats the case, eventually it will always be true that x2 is true."},{"studentID":"DziAzopaJDV4Nz8ugZowMZyrf2l2","answer":null,"explanation":null},{"studentID":"yqAbP1hwmpWXnQQRHWGW0uOlRPB3","answer":"G(!(x1 and !x2))  U  F(G(x2))","explanation":"I interpret \"for a while\" and \"but\" as a while operator. So x1 and !x2 is always false,  until  x2 will eventually always be true."},{"studentID":"obb14y1buwOu9DPHwVn15COD5Ky1","answer":null,"explanation":null},{"studentID":"oHfP2KoEE8PHFh9JpFBlrT9FonJ2","answer":"G(not (x1 and x2!) U G(x2))","explanation":"It is always true that we can't have x1 and x2! until x2 will always be true  "}]},{"prompt":"x2 always holds if x1 and x3 do not hold","rationale":"I think it is interesting because it tests different LTL related symbols. This could be used as a starter question.","answers":[{"studentID":"UKl2qkKWlKO6BQ9PwxsbdegpkDV2","answer":"w ⊨ G((¬x1 ∧ ¬x3) ⟹ x2)","explanation":"We always want x2 to be true if x1 and x3 are not true. To get both x1 and x3 to be false, we use ¬x1 ∧ ¬x3. That should imply that x2 is true, so we add (¬x1 ∧ ¬x3) ⟹ x2. This should always be true, so it should be true in all states, which means we have w ⊨ G((¬x1 ∧ ¬x3) ⟹ x2)."},{"studentID":"da61uKxwS4RS8uLw9e5aDhx9AAG2","answer":"NOT(x1 AND x3) -> Gx2","explanation":"If x1 and x3 do not both hold, the x2 must be always true (G)"},{"studentID":"3C5iQZrpLIPHa4l0KSVRUYUAeYn2","answer":"G(x1 v x3 v x2)","explanation":"x1 and x3 do not hold is (~x1^~x3)\nx2 always holds if \"x1 and x3 do not hold\" is \"x1 and x3 do not hold\" implies x2 \nG((~x1^~x3)->x2)\nwe substitute implies with ~p v q which is logically equivalent \nG(~(~x1^~x3) v x2)\nusing De Morgan's law we can simplify the above equation as \nG(x1 v x3 v x2)"},{"studentID":"j2h7kE6TUTe8mOHJ8n2gWkGvi922","answer":"(!x1 and !x3) -> G(x2)","explanation":"(!x1 and !x3) means that x1 and x3 do not hold at the first step and G(x2) means that x2 always holds."},{"studentID":"M513vZuSvAWfeOE0WZ7NWBieayn1","answer":"(!x1 and !x3) -> G(x2)","explanation":""},{"studentID":"XKjYJO7zc0dP1NfMtzP4jbagTLR2","answer":"(!x1 and !x3) => G(x2)","explanation":"since x2 was prefaced with always and not x1 or x3, I only put the G around x2."},{"studentID":"VXpluGJOfOUe37IfyjNfFz3GymV2","answer":"G((!x1 AND !x3) -> x2)","explanation":""},{"studentID":"LAeoyaF0twbF0V1g5eQ2GEPsxJE2","answer":"G(x1\\/x3\\/x2)","explanation":"I believe that the question is equivalent to saying it is always the case that one of the three variables must hold"},{"studentID":"2xb6qACusvPKldc9LfV1mfG35gz1","answer":"G(!(x1 and x3) => x2)","explanation":""},{"studentID":"mhnr5IV9YdS7voOl3kwhPQJ3bcn1","answer":"G(!(x1 and x3) => x2)","explanation":"x1 and x3's complement imply that x2 is true, this relationship always holds"},{"studentID":"1utNHrKBy7T4nb34YbOeaMGFzxl1","answer":null,"explanation":null},{"studentID":"Q6pogKCIaSh3uEueQnutSSKaDw33","answer":"G(X2 \\/ (X1 \\/ X3))","explanation":"Globally, if both x1 and x3 do not hold, x2 must hold (whereas if either x1 or x3 holds, we have no reason to care about x2, because the statement doesn't care about that scenario)"},{"studentID":"YzyRkeE37AhpGTSNU8zVMBwEojl1","answer":"G(!x1 and !x3)","explanation":"If not x1 and not x3 then x2 always holds (G function)"},{"studentID":"DfrktEsV96QCmKYSnC1SkAZ92Jm1","answer":"G(~(~x1 and ~x3) or x2)","explanation":"it is always the case that when both x1 and x3 do not hold, x2 does"},{"studentID":"rkJV8Z8X1ENdbW3Sk2dTT0GsMmn1","answer":"G ((¬x1 ∧ ¬x3) -> x2)","explanation":"It is always the case that, if x1 and x3 are false, x2 is true."}]},{"prompt":"It is always true that x1 is true and that x1 will eventually become false.","rationale":"No trace satisfies this description because a variable can't always be true, and yet eventually be false.","answers":[{"studentID":"XKjYJO7zc0dP1NfMtzP4jbagTLR2","answer":"G(x1 and F(!x1))","explanation":"This trace is unsatisfiable because x1 cannot be always true and eventually be false."},{"studentID":"uq5XAODUszU4PMKhfbmC0y7kdlO2","answer":"G(x1 and F(!x1))","explanation":"Can something like this actually happen? Or do we get a contradiction."},{"studentID":"5oLl7ZPijNYyMSwp55PwKSehzRq1","answer":"G(x1) /\\ F(~x1)","explanation":"x1 must always be true and (not x1) must eventually be true."},{"studentID":"UKl2qkKWlKO6BQ9PwxsbdegpkDV2","answer":"w ⊨ G(x1 ∧ F(¬x1))","explanation":"If x1 eventually becomes false, there must be some state where ¬x1 is true, so we have F(¬x1). We want this to be true and x1 to be true, so we get x1 ∧ F(¬x1). But it should always be true that x1 is true and x1 eventually becomes false, so it must be true in all states, meaning overall we have w ⊨ G(x1 ∧ F(¬x1))."},{"studentID":"kExUsPs90Caj3ooAw3UTw6JiTYU2","answer":"G(x1 and F(!x1))","explanation":"I'm not sure whether this is equivalent to G(x1) and F(!x1), but my intuition is that it would be equivalent."},{"studentID":"k6kvJj5VCUPWLj2ppeOMNVBQzeJ2","answer":"G(x1 and F(!x1)) ","explanation":"I used G to say this is always true and F to say eventually x1 becomes false"},{"studentID":"TWeauYjl4mWo4O6eKbArWZz1s4s1","answer":"G(x1 and F(!x1))","explanation":"G is always true, and F is eventually"},{"studentID":"kd663bJTz0hO7SfexfzikeYZgj53","answer":"Gx1 /\\ F(~x1)","explanation":"This can't be true"},{"studentID":"rx7fWLw9Uag06VhtzwrPHdWEKuC2","answer":"G(x1 and F(!x1))","explanation":"it always (G) holds that x1 is true and x1 is eventually (F) false."},{"studentID":"Urx7swvwyjUNbQ9lD233ds11JKJ3","answer":"G(x1 and F(!x1))","explanation":"Always refers to \"G\", and eventually refers to \"F\""},{"studentID":"7YpZ1Wx49VhhkqMHvH1TZC9HKEz1","answer":"G(x1 ^ Fx1)","explanation":"\"G\" tells us that the following formula is true in any state. Since the enclosed formula is a conjunction, this means that \"x1\" and \"Fx1\" is true in every state, i.e. for any state x1 is true in that state and there is at least one (or even infinitely many) future states where x1 is true."},{"studentID":"ehCdx7swHhPf72JGATgbRZ2e7rs1","answer":"G(x1) and F(!x1)","explanation":"G means always and F means eventually."},{"studentID":"3C5iQZrpLIPHa4l0KSVRUYUAeYn2","answer":"G(~x1 v F(~x1))","explanation":"The english statement is equivalent to the following logic:\n\"is it always true that ('x1 is true implies x1 will eventually become False')\"\n'x1 is true is just x1'\n'x1 eventually becomes False' is F(~x1)\n'implies' doesn't exist in LTL but we can use ~p v q which is equivalent to p->q \n'is it always true' is G the always true operation\n\nso we put everything together: \nG(x1 -> F(~x1))  <=>  G(~x1 v F(~x1))"},{"studentID":"0YnVb35gVyZjh40kz442E1Z1mli1","answer":"no solution","explanation":"looks like the problem no solution"},{"studentID":"yavIxXSH3vfpUlXFgyEZ39leNop2","answer":"F(x1) and F(!x1) and x1 U !x1","explanation":"F(x1) means x1 will be true at some point, F(!x1) means x1 will be false at some point and x1 U !x1 means that x1 will be true before it is false. "},{"studentID":"EbUb3Z6acpajSNs7t62nSh5UpGi2","answer":"G(x1) AND F(!x1)","explanation":"Always translates into global and eventually translates into F; the \"false\" is represented by the ! in the \"!x1\"."},{"studentID":"Mvw9fmUXFgVJjg6w1CCDcTkBdJo2","answer":"G(x1 and F(!x1))","explanation":"x1 holding and eventually x1 not holding is wrapped in a global operator"},{"studentID":"LAeoyaF0twbF0V1g5eQ2GEPsxJE2","answer":"G(x1 /\\ F(~x1))","explanation":"This one is pretty cool."},{"studentID":"DfrktEsV96QCmKYSnC1SkAZ92Jm1","answer":"G(x1 and F(~x1))","explanation":"direct translation"}]},{"prompt":"If x1, then it is always the case that x2 is true until x3 is false.","rationale":"I think people used a lot of whenever x1 is true, then ...\nBut I think there is a tricky difference between \"whenever x1 is true\",.. and \"x1, then ...\" because according to the definition, the proposition p is evaluated by whether w(0) maps p to true. That is: they are only concerned about i=0. However, \"whenever x1\" implies to all i","answers":[{"studentID":"TWeauYjl4mWo4O6eKbArWZz1s4s1","answer":"x1 -> G(x2 U !x3)","explanation":"G is always true and x U y means x is true until y is true"},{"studentID":"da61uKxwS4RS8uLw9e5aDhx9AAG2","answer":"x1 -> x2 U (NOT)x3","explanation":"If x1 is true, that implies that x2 must be true.  We know that x2 is true until NOT x3, so we can use the U operator here"},{"studentID":"AAzmbLYzxbcuw8WEJsNweNOfr542","answer":null,"explanation":null},{"studentID":"Iwmu1MjrCwcLIRbtZ2likbd2krr2","answer":"x1->G(x2U¬x3)","explanation":"It is a little confusing to me. I guess it means that if the initial x1 is true, then until x3 becomes false, x2 would be true. "},{"studentID":"XKjYJO7zc0dP1NfMtzP4jbagTLR2","answer":null,"explanation":null},{"studentID":"FJ1gcCB1SMXfbX4ehcXzcYHcs7l1","answer":"x1 => G(x2 U ~x3)","explanation":"We only consider x1 in the current state by the wording, and we want the conclusion to hold if x1 is true, hence \"x1 =>\". We're told that it's always the case (G), and we want x2 to hold until x3 doesn't (x2 U ~x3).\n\nThis is an odd one, really. If it's always the case that x2 is true until x3 is false, then x2 must be true whenever x3 is not false (i.e. x3 is true), so we can write this as G(x3 => x2) as well."},{"studentID":"yLK6W8nyVrMUkNMyxFYLNsJdaPt2","answer":"x1->G(x2 U !x3)","explanation":"So since it says \"if x1 then, this basically means writing x1->. Then G means that the expression always holds, which is why I put the expression to the right of the arrow inside of G and the U means until, which is why I put x2 U !x3, since ! means false. "},{"studentID":"eaIqaTs5sLTe88iSf2SdfYFDqPs2","answer":null,"explanation":null},{"studentID":"CUpKAZiiOrMlB7VEhcBrcxBDduN2","answer":"x1 -> x2 U !x3","explanation":"if x1 is true, this implies (->) x2 is true until (U) x3 is false (!)"},{"studentID":"SXuWPt2DVGRMnfN2ELdVux2pv9j2","answer":"x1 => G(x2 U !x3)","explanation":"If/then = =>, always = G, until = U"},{"studentID":"zKquIv2iqOPUbju84kD6x2oqxQC3","answer":"x1 => G(x2 U !x3)","explanation":"x1 implies that G=(always) always x2 is true U=(until) until x3 is false."},{"studentID":"DziAzopaJDV4Nz8ugZowMZyrf2l2","answer":"x1 -> G(x2 U !x3)","explanation":"if x1, we can imply that, always, x2 is true until x3 is false"},{"studentID":"Ao8FhZPEPeV6WdP0CYNeEiGGwP52","answer":"¬x1  ∨ G(x2 U x3)","explanation":"This says that if x1 is not true then x2 until x3 is always true. "},{"studentID":"j2h7kE6TUTe8mOHJ8n2gWkGvi922","answer":"x1 -> G(x2 U !x3)","explanation":"x1 means that x1 is true, G means always, x2 U !x3 means that x2 is true until x3 is not true"},{"studentID":"YzyRkeE37AhpGTSNU8zVMBwEojl1","answer":null,"explanation":null},{"studentID":"UKl2qkKWlKO6BQ9PwxsbdegpkDV2","answer":"w ⊨ x1 ⟹ x2 U ¬x3","explanation":"If x1 is true, then we want x2 to always be true until x3 is false. So, at some point x3 is false, which means that there exists an i such that w^i ⊨ ¬x3, and forall j which are between 0 and that i w^j ⊨ x2 (because those traces come before the one where x3 is false and we want x2 to be true in all of them). This translates into x2 U ¬x3, but we also need the if x1 then x2 U ¬x3, so we have w ⊨ x1 ⟹ x2 U ¬x3."},{"studentID":"fRdxvbOnDTSVL5Ps9hTMqWSV5gc2","answer":"x1 -> G(x2 U !x3)","explanation":"If x1, the -> means implies. x2 U !x3 means that x2 is true until x3 becomes false. This is implied by x1. The G means it is always the case."},{"studentID":"yqAbP1hwmpWXnQQRHWGW0uOlRPB3","answer":null,"explanation":null},{"studentID":"p81246jCdnf8jPP6ckaxgaA9ceB3","answer":"x1 => (F(-x3) => X(x2)-)","explanation":"x1 holding implies that if eventually x3 is false, x2 will hold until then."},{"studentID":"u5LtkhMrVVVNvSHlNyzDQIjuWQl2","answer":"x1 -> G(x2 U !x3)","explanation":""},{"studentID":"M513vZuSvAWfeOE0WZ7NWBieayn1","answer":"G(x1 -> (x2 U !x3))","explanation":""},{"studentID":"UJYax3ztBqcD2acHhEY8qP4lBhG3","answer":"G(x1 U (x2 W !x3))","explanation":"This is another use of the \"weak until\" operator"},{"studentID":"k6kvJj5VCUPWLj2ppeOMNVBQzeJ2","answer":"G(x1 -> G(x2 U !x3))","explanation":"I am using G to say that this always holds. I am using U to express x2 being true until x3 is false."},{"studentID":"o4OspE6hSFUWj93icU8e3H220fm1","answer":null,"explanation":null},{"studentID":"uhSgQJpSx7dbcXRJqnQpLJPHK8s1","answer":"x1:=true -> G( x2:= true U x3:= false) ","explanation":"I used the implies because it is an if-then relationship, and the next condition is always the case, and I used U because it means that something holds until another condition. "},{"studentID":"R94tBoHz8ySNViJBvSke3qpd7N03","answer":"x1 => G(x2 U !x3)","explanation":"The implies is direct. The until is a little bit unclear, but how I am interpreting it, I am using U."},{"studentID":"3C5iQZrpLIPHa4l0KSVRUYUAeYn2","answer":"~x1 v (x2 v F(~x3))","explanation":"we start with subpredicate 'x2 is true until x3 is False'\nx2 v F(x3) means x2 is True until x3 is True,  so F(~x3) means until F3 is False. \nso we have x2 v F(~x3)\nnow if-then is equivalent to implies, but LTL does not have implies, so we use \nlogically equivalent statement p->q <=> ~p v q"},{"studentID":"XsaC3AijqlTPGgknfTWr9Czhwed2","answer":"x1 -> G(x2 F(X(-x3)))","explanation":"this is my answer because x1 implies \"->\" that it is always the case \"G( )\" that x2 is true, and then eventually \"F( )\" the next thing is \"X( )\" x3 is false. I used the \" - \" operator to represent the not operator because I didn't know how to type the not logical operator"}]},{"prompt":"If we know that x1 will eventually be true, then we know that x2 will be true until x1 is true. Otherwise, all we know is that x3 is true.","rationale":"I found this structure interesting since LTL doesn't have an \"if-else\" structure so you will instead have to use a double implication.","answers":[{"studentID":"kd663bJTz0hO7SfexfzikeYZgj53","answer":"(F x1 => x1 U x2) \n~(F x1) => x3\n","explanation":"finally x1 (x1 is eventually true) implies x2 until x1 \nnot finally x1 implies x3"},{"studentID":"Z8I0Gua8DxZT3Lr3BGcIfZxlivI2","answer":null,"explanation":null},{"studentID":"WAQ3dKACLtX8yKwCEVHHryA0JWz1","answer":"(x2 U x1) or x3","explanation":"x2 U x1 means that x1 is eventually true and that x2 is true until then. or x3 means that the previous is true or x3 is true"},{"studentID":"TWeauYjl4mWo4O6eKbArWZz1s4s1","answer":"(F(x1) -> (x2 U x1)) or x3","explanation":"F is eventually true, and x U y means x is true until y is true"},{"studentID":"phrbqZWVjcRh1ZJhWZHdh1yEhMZ2","answer":"(F(x1) => x2 U x1) and (!F(x1) => x3)","explanation":"F(x1) => x2 U x1 : means that if x1 is eventually true, then x2 will be true \nF(x1) => x3 : means that if x1 is not eventually true, then x3 is true"},{"studentID":"0YnVb35gVyZjh40kz442E1Z1mli1","answer":"F(x1) -> x2 U x1 & F(!x1) -> x3 ","explanation":"two conditions need to hold"}]},{"prompt":"x1 will always be true if x2 is false, unless x3 is also true ","rationale":"I think this would be an interesting case because x1 as a variable will be dependent on two other variables","answers":[{"studentID":"rkJV8Z8X1ENdbW3Sk2dTT0GsMmn1","answer":"G ((¬x2 ∧ ¬x3) -> x1)","explanation":"It is always the case that x1 is true if both x2 and x3 are false."},{"studentID":"UJYax3ztBqcD2acHhEY8qP4lBhG3","answer":"G(x1 <=> !x2 and !x3)","explanation":"The question didn't really specify what x1 is if x3 is true but I took it to mean false."},{"studentID":"Iwmu1MjrCwcLIRbtZ2likbd2krr2","answer":"G((x2∧¬x3)->x1)","explanation":"Rephrase the sentence, then we have: If x2 is false and x3 is not true, then x1 must always be true. "},{"studentID":"rsp3YalY4iYInzJzXy67djOCMdz2","answer":null,"explanation":null},{"studentID":"QNFbaiaIhcRfRQoHtE9QvXtkhxf1","answer":"G(x1) |= !x2 ∧ !x3","explanation":"G(x1) means that x1 will always be true, but the satisfaction relation |= means that G(x1) will only occur as long as !x2 (meaning x2 is false) and as long as x3 is false. The fact that x1 will always be true as long as x2 is false and x3 is false is captured by the statement !x2 ∧ !x3."},{"studentID":"1PfpKQ5FbSaFVpjLU0zEvi2Vsni2","answer":"G(x1) and not x2 and not x3","explanation":"G(x1) means in words that x1 is always true. Together, this means that G(x1) always true if x2 is false and x2 is false"},{"studentID":"2xb6qACusvPKldc9LfV1mfG35gz1","answer":"G(!x1 and !x3 => x1)","explanation":"We need a Global quantifier and an implication."},{"studentID":"VyRu6HFhkSdTXzQOX81tSoaP91w1","answer":null,"explanation":null},{"studentID":"DqLJt0Zj9WSlYXNbRSWqy1aCnyf2","answer":"G(!x2 => (x1 or x3))","explanation":"We use the \"G\" formula to enforce that the following formula will always be true, and then \"!x2 => (x1 or x3)\" to encode that, if x2 is false, then either x1 is true, or x3 was also true."},{"studentID":"SX5qjuY4LhdUlbePO48FvB797G53","answer":"G(-x2 => (x1 or x3))","explanation":"Whenever x2 is false, x1 will be true or x3 will be true."},{"studentID":"DziAzopaJDV4Nz8ugZowMZyrf2l2","answer":"G((!x2 ∧ !x3) -> x1)","explanation":"always, if x2 is false and x3 is false, x1 will be true"},{"studentID":"xnwt9vlgrKQMCMF8UkHGCLYNOxw2","answer":"NOT(x2) AND NOT(x3) -> G(x1)","explanation":"When x2 is false and x3 is false (equivalent to \"unless x3 is also true\"), x1 will always be true."},{"studentID":"FedMWmwEd7W3C68gTqm66aRiqns2","answer":"G(!x2 -> x1) or x3","explanation":"if x3 is true, x1 won't always be true. If x2 is false, then x1 will always be true."},{"studentID":"eaIqaTs5sLTe88iSf2SdfYFDqPs2","answer":"(!x2 and !x3) => G(x1)","explanation":""},{"studentID":"R94tBoHz8ySNViJBvSke3qpd7N03","answer":"G(!x2 and !x3 => x1)\nEquivalently:\nG(!(!x2 and !x3) or x1)","explanation":"I am interpreting this statement as Always x1 is true if ....\nIt may also be interpreted as x1 is always true if ... ever occurs.\nOther than the \"always\" the statement can be interpreted as !x2 and !x3 => x1 which is equivalent to !(!x2 and !x3) or x1."},{"studentID":"mhnr5IV9YdS7voOl3kwhPQJ3bcn1","answer":"G((!x2 and !x3) => x1)","explanation":"The relationship between x2 and x3 implies the status of x1"},{"studentID":"da61uKxwS4RS8uLw9e5aDhx9AAG2","answer":"NOT x2 -> x3 OR G x2","explanation":"if NOT x2 is true, that implies that either x3 is true OR x2 is always true (G)."},{"studentID":"5IPmn9xCANgNuM7LIh9zG4wqqQc2","answer":"G((!x2 => x1) or x3)","explanation":"I'm not sure if I expressed the idea of \"unless\" correctly here. The formula starts with (!x2 => x1) because it always holds that x1 is true if x2 is false (i.e. x2 being false implies that x1 is true). We then have \"or x3\" because this is true unless x3 is also true. The whole thing is wrapped in a G because it always holds."}]},{"prompt":"if x1 is ever true at some point, x2 must always be true","rationale":"This is a question that Tim thought would be interesting.","answers":[{"studentID":"XXDQ67q4UiSR2kFxVzhaxL1hRZC3","answer":null,"explanation":null},{"studentID":"T4nr7nKQtkexYyVAi3NwCSqKC5n2","answer":"F(x1) => G(x2)","explanation":"x1 being true at some point (F) implies x2 is always true (G)"},{"studentID":"CUpKAZiiOrMlB7VEhcBrcxBDduN2","answer":null,"explanation":null},{"studentID":"FRxTfpBnCXSBY762KVw7F5DTJ0r1","answer":"F(x1) -> G(x2)","explanation":"if x1 is eventually true at some point, it implies that x2 is always true"},{"studentID":"da61uKxwS4RS8uLw9e5aDhx9AAG2","answer":"x1 -> Gx2","explanation":"if x1 is true, then x2 should always be true (G)"},{"studentID":"Olm3iZ1G75hC3g8kxg51POXFM402","answer":"F(x1) -> G(x2)","explanation":"if finally x1 is true, the later x2 will always be true"},{"studentID":"fRdxvbOnDTSVL5Ps9hTMqWSV5gc2","answer":"F(x1) -> G(x2)","explanation":"F(x1) means x eventually being true at a point. G(x2) means x2 is always true. -> means that x1 becoming true implies that x2 is always true."},{"studentID":"UJYax3ztBqcD2acHhEY8qP4lBhG3","answer":"G(x1 U G(x2))","explanation":"The second globally/always should ignore states passed through by the first"},{"studentID":"1PfpKQ5FbSaFVpjLU0zEvi2Vsni2","answer":"F(x1) and G(x2)","explanation":"I think this means that x1 eventually true must happen with x2 always being true. Again, not sure how to quantify the \"if then\" statement because there is no => operator."},{"studentID":"kOYh8lB1WQhEgx5Pte67U4XSnE93","answer":"x1 => G(x2)","explanation":"This is saying that if there is an instance of x1 being true, we must say for always (G) that x2 is true. I use an implies to link these two observations together."},{"studentID":"AAzmbLYzxbcuw8WEJsNweNOfr542","answer":"Fx1 implies Gx2","explanation":"eventually x1 implies globally x2"},{"studentID":"rx7fWLw9Uag06VhtzwrPHdWEKuC2","answer":null,"explanation":null},{"studentID":"kd663bJTz0hO7SfexfzikeYZgj53","answer":"(F x1) => (G x2)","explanation":"Finally x1 implies global x2"},{"studentID":"FJ1gcCB1SMXfbX4ehcXzcYHcs7l1","answer":"F(x1) => G(x2)","explanation":"The if... then... structure gives us \"=>\", and we just have to interpret the hypothesis and conclusion. The hypothesis is x1 being true at some point (F), and the conclusion is x2 being true always (G). "},{"studentID":"SX5qjuY4LhdUlbePO48FvB797G53","answer":"F(x1) => G(x2)","explanation":"if x1 is eventually true, x2 will always be true."},{"studentID":"mkSbSzp0rUQ30XSeUq1F4HqG0S82","answer":"F(x1) => G(x2)","explanation":"If we eventually encounter x1, x2 is always true."},{"studentID":"eaIqaTs5sLTe88iSf2SdfYFDqPs2","answer":"F(x1) => G(x2)","explanation":""},{"studentID":"qMF6ehxbIhSGK4673vpXIDWqRk92","answer":"F(x1) => G(X2)","explanation":"simple combination of F and G"},{"studentID":"o4OspE6hSFUWj93icU8e3H220fm1","answer":"G(x1 implies G(x2))","explanation":"G goes through all the states, and if at any of them x1 is true, then x2 is true globally."},{"studentID":"lRaLOybCkkdkd88UUN9jWGgL9fB3","answer":"F(x1) -> G(x2)","explanation":"Importantly, the '-> G(x2)' is outside of the F, since we want x2 to hold even in the states before x1 is true"},{"studentID":"06qfdQBcQyMQkXqkqBmyYkv99ns2","answer":"F(x1) => G(x2)","explanation":"If x1 is eventually true (this will hold as long as x1 is ever true in some state), then x2 must be true globally (always)."},{"studentID":"XsaC3AijqlTPGgknfTWr9Czhwed2","answer":"F(x1) -> G(x1)","explanation":"The above is my answer because F( ) means eventually true and G( ) means globally/always true. I used the implication arrow to show that something eventually being true means it is always true for the set of traces defined by this LTL statement. "},{"studentID":"5oLl7ZPijNYyMSwp55PwKSehzRq1","answer":"G(x2) /\\ F(x1)","explanation":"For traces where x1 is eventually true, or true at some point, you must also have that x2 is always true."},{"studentID":"qsvPOzEQ1NeTrWs1iQmcqVOTHOJ3","answer":"F(x1) => G(x2)","explanation":"F(x1) states that at some point x1 becomes true, G(x2) states that x2 is always true."},{"studentID":"zKquIv2iqOPUbju84kD6x2oqxQC3","answer":"F(x1) => G(x2)","explanation":"If x1 is eventually true  F(x1) that implies that x2 is always true G(x2)."},{"studentID":"k6kvJj5VCUPWLj2ppeOMNVBQzeJ2","answer":"F(x1 -> G(x2))","explanation":"I'm trying to say that eventually (F) if x1 is true then it implies that x2 is always (G) true"}]},{"prompt":"if next value of x1 is false, then x2 must just transitioned from true to false, and x3 must just transitioned from false to true","rationale":"my question requires the understanding of state transition and the use of the mix of multiple syntax","answers":[{"studentID":"kd663bJTz0hO7SfexfzikeYZgj53","answer":"~Xx1 => (x2 /\\ ~Xx2) /\\ (~x3 /\\ Xx3)","explanation":"not next state x1 implies x2 and not next state x2 and not x3 and next state x3"},{"studentID":"qMF6ehxbIhSGK4673vpXIDWqRk92","answer":"(X2 U !X2) and (!X3 U X3) => !X1","explanation":"U would be transition from one state to another"},{"studentID":"EbUb3Z6acpajSNs7t62nSh5UpGi2","answer":null,"explanation":null},{"studentID":"AxWttnGXbFOGMdMAoOcSQHoPFuB2","answer":"X(!x1) => !x2 and x3","explanation":"The if notation is a bit confusing, but as I understand it, the phrasing as an implies guarantees that the outcome will at least in the trace if it holds true for the LTL."}]},{"prompt":"at some point x1 is true and x2 is false thereafter","rationale":"This is a question that Tim thought would be interesting.","answers":[{"studentID":"Ao8FhZPEPeV6WdP0CYNeEiGGwP52","answer":null,"explanation":null},{"studentID":"WAQ3dKACLtX8yKwCEVHHryA0JWz1","answer":"F(x1 and G(X(!x2)))","explanation":"F means eventually true. The \"and\" means that both must be true. So x1 is true, and G(X(!x2)) is true. G means that X(!x2) is always true, and the X means the x2 is false in the next state. I am unsure if the X is needed due to the wording of the question because G means always true which would constrain x2 to be false in the state that x1 is true, while X means that it is only the states after."},{"studentID":"da61uKxwS4RS8uLw9e5aDhx9AAG2","answer":"F(x1 -> G NOT x2)","explanation":"If x1 is true, that implies that NOT x2 should be true in all subsequent states.  Since this happens \"at some point,\" then we must put the F on the outside of the expression"},{"studentID":"AAzmbLYzxbcuw8WEJsNweNOfr542","answer":"Fx1 AND x1 implies G(NOTx2)","explanation":"Eventually x1 is true, and if x1 is true, x2 is not true globally thereafter"},{"studentID":"FRxTfpBnCXSBY762KVw7F5DTJ0r1","answer":"F(x1 and G(X(!x2)))","explanation":"Eventually there will be a state where x1 is true, and all its future states has x2 equals to false"},{"studentID":"g189tDKZqyfaI2GiXyXWcUWilJB2","answer":"F (x1 /\\ (X G ~x2))","explanation":"\"At some point\" indicates the statement is wrapped in an \"eventually\" operator F. At the eventual state, we need both x1 to be true and the statement regarding x2 to hold, so we and (/\\) x1 with that statement. The \"thereafter\" in \"x2 is false thereafter\" implies 1) that x2 is false for all states after the state in which x1 is true, and 2) that x2 is not necessarily false in the state where x1 is true. The former corresponds to the \"always\" operator G, while the latter adds a \"next\" operator X before the always."},{"studentID":"AJhRpKsvXyRzhbZwJMshU1xBreG3","answer":"F(x1 and X(!x2))","explanation":"x1 and X(!x2) describes a state where x1 is true and x2 will be false in the next state. Wrapping this in F means that state occurs at some point."},{"studentID":"1PfpKQ5FbSaFVpjLU0zEvi2Vsni2","answer":"F(x1 and X(G(not x2)))","explanation":"F(x1 and X(G(not x2))) means in words that there is eventually a state where x1 is true and in the next state x2 is always false"},{"studentID":"FK5jY3NfsvSIHK38KFpV6g8dFak1","answer":"Fx1 ^ (x1 --> XG~x2)","explanation":"at some point x1 is true => Fx1\nafter x1 is true x2 is false all the time after that afterword (x1 --> XG~x2)"},{"studentID":"Olm3iZ1G75hC3g8kxg51POXFM402","answer":null,"explanation":null},{"studentID":"ZdXWZhb3FQamAIjPsR8DFsmHhwe2","answer":"F(x1)  -> -x2","explanation":"I at some point x1 is true means it's eventually true and then I took x2 is false thereafter as an implies statement"},{"studentID":"FJ1gcCB1SMXfbX4ehcXzcYHcs7l1","answer":"F(x1 ^ X(G(~x2)))","explanation":"We want this to be true eventually (F), that x1 is true and (x1 ^) x2 is false there after. I interpret \"there after\" as strictly in the future, and so X(G(~x2))."},{"studentID":"u5LtkhMrVVVNvSHlNyzDQIjuWQl2","answer":"X(x1 and !x2)","explanation":"According to \"at some point\" and \"thereafter\", this formula is to describe\n (x1 is true and x2 is false) holds along the path starting at some state s_i."},{"studentID":"SXuWPt2DVGRMnfN2ELdVux2pv9j2","answer":"F(x1) U G(!x2)","explanation":"at some point = F, x2 is false = !x2, false thereafter = U G"},{"studentID":"Urx7swvwyjUNbQ9lD233ds11JKJ3","answer":"F(x1 ^ (~x2))","explanation":"x1 means x1 is true and ~x2 means x2 is false. Since it says \"thereafter\", we should use F."},{"studentID":"QNFbaiaIhcRfRQoHtE9QvXtkhxf1","answer":"F(x1 = True) --> x2 |= False if x1 = True","explanation":"F(x1 = True) means that x1 will eventually be true. |= is the satisfaction relation, meaning that x2 becomes false if x1 becomes True."},{"studentID":"yLK6W8nyVrMUkNMyxFYLNsJdaPt2","answer":"F(x1-> ¬x2)","explanation":"As Professor Nelson described in lecture, eventually/finally could be denoted as F, which is essentially the same thing as saying \"at some point\". From my understanding of the wording of question, once x1 is true, then x2 is false, which is what I denoted when I put x1->¬x2. To represent false, I used the ¬ symbol. "},{"studentID":"zKquIv2iqOPUbju84kD6x2oqxQC3","answer":"F(x1 and x1=>G(!x2))","explanation":"F = (eventually), so F(x1 and x1=>G(!x2)) means that at some point x1 is true and if x1 is true x2 becomes always false. "},{"studentID":"rkJV8Z8X1ENdbW3Sk2dTT0GsMmn1","answer":"F (x1 -> G(¬x2))","explanation":"Eventually, x1 being true implies x2 will always be false thereafter."},{"studentID":"CUpKAZiiOrMlB7VEhcBrcxBDduN2","answer":"F(x1 ^ X(!x2))","explanation":"Eventually (F), x1 is true, and then the next x2's (X) are false (!)"},{"studentID":"5oLl7ZPijNYyMSwp55PwKSehzRq1","answer":null,"explanation":null},{"studentID":"mhnr5IV9YdS7voOl3kwhPQJ3bcn1","answer":"F(x1) => !x2","explanation":"when x1 becomes true, x2 is no longer true"},{"studentID":"Q6pogKCIaSh3uEueQnutSSKaDw33","answer":"F(x1)->X(G(~x2))","explanation":"eventually x1 being true implies that from the next step x2 is false forever"},{"studentID":"T4nr7nKQtkexYyVAi3NwCSqKC5n2","answer":"F(x1) ^ G(x1 -> G(X(not x2)))","explanation":"x1 is true at some point, and same rationale as the last problem, x1 ever being true implies consequent states have x2 being false"},{"studentID":"lRaLOybCkkdkd88UUN9jWGgL9fB3","answer":"F(x1 and X(G(!x2)))","explanation":"At some point translates to F, and thereafter seems to imply strictly in the future so I use X before G(!x2)"},{"studentID":"XsaC3AijqlTPGgknfTWr9Czhwed2","answer":"F(x1)X(G(-x2))","explanation":"This expression is my answer because eventually x1 is true \"F(x1)\", then the next thing \"X( )\" is always \"G( )\" not x2 \"-x2\". I am using \"-\" to represent the not logical operator. "},{"studentID":"eaIqaTs5sLTe88iSf2SdfYFDqPs2","answer":"F(x1) and G(X(!x2))","explanation":""},{"studentID":"fRdxvbOnDTSVL5Ps9hTMqWSV5gc2","answer":null,"explanation":null},{"studentID":"79DF8m2XmUOKjV8Ob9evefRWNHw1","answer":"not possible in LTL","explanation":"I am actually not sure if such an LTL is possible, since it sounds like availability. "}]},{"prompt":"if it is raining you need to take an unberalla. If you take an unberalla, it does not necessarily mean it is raining outside. ","rationale":"Some relationship is single way.","answers":[]},{"prompt":"for every state if x1 is true, then  x2 and x3 should be false, if x2 or x3 is true, x1 is false.","rationale":"it's actually a read/write lock implementation, if write lock is owned, there cannot be any read lock to lock the file, if the read lock is owned it can still be lock by some other read lock but cannot be locked by the write lock.","answers":[{"studentID":"mkSbSzp0rUQ30XSeUq1F4HqG0S82","answer":"x1 => (!x2 && !x3), (x2 || x3) => !x1","explanation":"This is made of two parts: x1 being true implies neither x2 nor x3 are true, and either x2 or x3 being true implies x1 is false."},{"studentID":"Urx7swvwyjUNbQ9lD233ds11JKJ3","answer":"G(~x1 v (~x2 ^ ~x3))","explanation":"\"if x1 is true, then x2 and x3 should be false\" and \"if x2 or x3 is true, x1 is false\" mean the same thing, since it stands for every state, we should use G to indicate that"},{"studentID":"3C5iQZrpLIPHa4l0KSVRUYUAeYn2","answer":"G((~x1 v (x2 v x3)) ^ ((~x2 ^ ~x3) v ~x1))","explanation":"The english statement is equivalent to \n(always) \"x1 implies x2 is False and x3 is False and x2 or x3 is true implies x1 is False\"\nG((x1 -> (~x2^~x3)) ^ ((x2 v x3) -> ~x1))\nSince LTL does not have implies, we will use logically equivalent statement p->q <=> ~p v q\nG((~x1 v ~(~x2^~x3)) ^ (~(x2 v x3) v ~x1))\nwe can then simplifies the logical statement above with De Morgan's logical law \nG((~x1 v (x2 v x3)) ^ ((~x2 ^ ~x3) v ~x1))"},{"studentID":"WAQ3dKACLtX8yKwCEVHHryA0JWz1","answer":"G(x1 => (!x2 and !x3) and (x2 or X3) => !x1)","explanation":"I got this in the LTL to English. G means for every state. x1 => (!x2 and !x3) means that if x1 is true then x2 and x3 are false. And (x2 or X3) => !x1 means that if x2 or x3 are true then x1 is false"},{"studentID":"0HC3dpmLyKeoD74DguNF8DNwqrj1","answer":"(x1 -> !x2 and !x3) OR ((x2 OR x3) -> !x1)","explanation":"I pretty much just encoded what the prompt was saying word for word."},{"studentID":"LKGb8fPfkfZIpgmptBwJeE7DlWm2","answer":"G((x1=> !x2 and !x3) and ((x2 or x3)=> !x1))","explanation":"for every state is G and then each if statement becomes an implies"},{"studentID":"yavIxXSH3vfpUlXFgyEZ39leNop2","answer":"G(x1 => !(x2 and x3) and !(x2 and x3) => x1)","explanation":"We can express each \"if\" as an implication. We use the G to enforce the \"for every state\" "},{"studentID":"0YnVb35gVyZjh40kz442E1Z1mli1","answer":"(x1->(!x2 & !x3)) &((x2 | x3)->!x1)","explanation":"Two conditions, we need to satisfied"},{"studentID":"obb14y1buwOu9DPHwVn15COD5Ky1","answer":"G( (x1 => (~x2 /\\ ~x3)) /\\ ((x2 \\/ x3) => ~x1))","explanation":"(x1 => (~x2 /\\ ~x3)) = x1 implies x2 and x3 are both false\n((x2 \\/ x3) => ~x1) = if x2 or x3 is true, x1 is false. "},{"studentID":"EbUb3Z6acpajSNs7t62nSh5UpGi2","answer":"G((x1 <=> (!x2 AND !x3))","explanation":"Not sure what this was trying to say; assuming it meant to and the two if's. In that case, then x1 being true depends on both x2 and x3 being false, and vice versa. This vice versa quality indicated an iff to me."}]},{"prompt":"x1 is only true when x2 in the next next state is not true.","rationale":"x1 <=> X(X(!x2)) : This expression is interesting because one variable's truth value depends on another variable's next next state, which seems to be similar to something that might be expressed while iterating through a collection in a standard programming language.","answers":[{"studentID":"Ao8FhZPEPeV6WdP0CYNeEiGGwP52","answer":"G(¬(x1 ^ X(x2)))","explanation":"This says that it is always true that it is not the case that x1 is true and x2 in the next state is also is true "},{"studentID":"rx7fWLw9Uag06VhtzwrPHdWEKuC2","answer":"X(!x2) -> x1","explanation":"if x2 in the next state (using X) is false, x1 holds"},{"studentID":"FedMWmwEd7W3C68gTqm66aRiqns2","answer":"x1 -> X(X(!x2)","explanation":"This statement shows how x1 is true when the next next state of x2 is false"},{"studentID":"oHfP2KoEE8PHFh9JpFBlrT9FonJ2","answer":"G(X(!x2) => x1)","explanation":"Its always true that if in the next state X, x2 is false, x1 is true in the current one"},{"studentID":"0HC3dpmLyKeoD74DguNF8DNwqrj1","answer":"x1 => XX!x2","explanation":"I encoded it word for word XX means next next, I think?"},{"studentID":"phrbqZWVjcRh1ZJhWZHdh1yEhMZ2","answer":"X(X(x2)) => !x1","explanation":"This means that x1 must be false in the case where x2 in the next next state is true. Otherwise, it can be either true or false\nX(X(x2)) : means that x2 is false in the next next state"},{"studentID":"SX5qjuY4LhdUlbePO48FvB797G53","answer":"G(x1 => -X(X(x2)))","explanation":"When x1 is true in state i, x2 will be false in state i+2"}]},{"prompt":"It is never eventually false that if x1 is true then x2 and x3 are true, but only after x4 is true (which will happen).","rationale":"I think this formula is interesting because it utilizes a lot of the temporal operators (global, until, eventually) while also bringing in the logical operator of \"and\" and \"implies\". Also, the way it's phrased by putting \"but only after\" at the end could require a bit more thought. Also, never eventually false is just a round about way of saying always :)","answers":[{"studentID":"FK5jY3NfsvSIHK38KFpV6g8dFak1","answer":"Fx4 ^ (~x4UX(G~F~(x1-->x2^x3)))","explanation":"Firstly we know that x4 will eventually be true -> Fx4\nAnd let's consider (It is never eventually false that if x1 is true then x2 and x3 are true)\nwhich can be written as G~F~(x1-->x2^x3) (never p means for all time ~p  => (G~p) ) (Eventually false that p is F~p)\nBut this condition only occurs after x4 is true. The other to say this is that ~x4 until the next time step G~F~(x1-->x2^x3).\nTherefore, Fx4 ^ (~x4UX(G~F~(x1-->x2^x3))) would encode everything."},{"studentID":"Z8I0Gua8DxZT3Lr3BGcIfZxlivI2","answer":"X(X(X(X( !F( !(x1 -> (x2 and x3) )) ) ) ) ) implies !F( !(x1 -> (x2 and x3) )) ","explanation":"So the main internal statement with the !F... means that \"It is never eventually false that if x1 is true then x2 and x3 are true\" . That main statement after x4 implies the statement itself to fulfill the property \"but only after x4 is true\""},{"studentID":"rkJV8Z8X1ENdbW3Sk2dTT0GsMmn1","answer":"(F x4) U (G (x1 -> x2 ∧ x3))","explanation":"x4 is eventually true up until some state, after which is it always true that x2 and x3 are true if x1 is true."},{"studentID":"0HC3dpmLyKeoD74DguNF8DNwqrj1","answer":"G(F(x1 => (x2 AND x3) U (x4))","explanation":"Never eventually false is equivalent to always eventually true, so I nested the entire statement in G(F()). x1 implies that x2 and x3 are true, the U x4 makes it so that x4 being true must happen first."},{"studentID":"k6kvJj5VCUPWLj2ppeOMNVBQzeJ2","answer":"! F(!( x4 -> X(x1 -> (x2 and x3))) and G(x4)","explanation":"I tried to express this using F for eventually, X to check the states after x4 is true, and G to say that x4 will be true. However, I am confused about this one."},{"studentID":"XXDQ67q4UiSR2kFxVzhaxL1hRZC3","answer":"x4=>F(¬(x1=>x2 ∧ x3)\n¬x4=>F(x1=>x2 ∧  x3))","explanation":"This expression is actually equivalent to  \n    the statement \"if x1 is true then x2 and x3 are true\" is true iff x4 is true."},{"studentID":"uq5XAODUszU4PMKhfbmC0y7kdlO2","answer":null,"explanation":null},{"studentID":"da61uKxwS4RS8uLw9e5aDhx9AAG2","answer":"G(Fx4 U (x1 -> (x2 AND x3)))","explanation":"We know that x4 must be true, hence the F.  Then, we know that if x4 is true, then the next thing to happens should be that x1 is true, and if x1 is true (hence the implication), then both x2 and x3 should be true.  Finally, we put a G around the whole expression because \"never eventually false\" is the same as always."},{"studentID":"phrbqZWVjcRh1ZJhWZHdh1yEhMZ2","answer":"x4 => G( x1 => (x2 and x3))","explanation":"This means that it is always true that if x1 is true, then x2 and x3 are true. But only after x4 is true. Therefore, x4 implies that in the trace following the state where x4 is true, the other part should always be true. \n\nx1 -> (x2 and x3): means that if x1 is true and x2 and x3 are true"},{"studentID":"eaIqaTs5sLTe88iSf2SdfYFDqPs2","answer":null,"explanation":null},{"studentID":"5IPmn9xCANgNuM7LIh9zG4wqqQc2","answer":"!G(F(G((x1 => (x2 and x2)) <=> x4)))","explanation":"I had a bit of a hard time translating this one -- I think I got confused about the second half, where something is true only after x4 is true which will happen. I used the G operator to account for this, but not sure if I put it in the right place. I used bi-implication to show that (x1 => (x2 and x2)) iff x4 is true. The whole thing is wrapped in a !GF because we know that the formula is never eventually false."},{"studentID":"VcwHvUABF3hqOeJni9XH0HFRNwJ2","answer":"G(   ((x1 => (x2 and x3))  U  x4)  and   F(x4)  )","explanation":"It is never eventually false is the same as it is always true, so I used the G symbol for that and then I expressed that x1 implies x2 and x3 until x4 is true and used F(x4) to ensure that eventually x4 will be true."},{"studentID":"fRdxvbOnDTSVL5Ps9hTMqWSV5gc2","answer":"F(x4) | G(F(x1 ^ x2 ^ x3 iff x4))","explanation":"We know that x4 will eventually become true: F(x4). I translated \"never eventually false\" to \"always eventually true\" which if G(F()).\nThen I know that if x1 is true then x2 and x3 are also true, which is x1^x2^x3. They are only true if x4 is true, which is iff x4."},{"studentID":"UJYax3ztBqcD2acHhEY8qP4lBhG3","answer":"F(x4 and X(G(!F(!(x1 -> (x2 and x3))))))","explanation":"Eventually x4 will be true and, from the next state onward, globally it is not eventually false that if x1 then x2 and x3"},{"studentID":"YZmWKZlgaZOrzGYNRp4TUVv5pZ13","answer":"F(x4) U G(not(F(x1 => (x2 and x3))))","explanation":"x4 WILL at some moment be true; this can be expressed by F (finally). after that, (until), it will always be true that it is NOT the case that, eventually, x1 being true implies x2 and x3 being true."},{"studentID":"2xb6qACusvPKldc9LfV1mfG35gz1","answer":"G(x4 U x1 => x2, x3)","explanation":"never eventually false == always"},{"studentID":"LKGb8fPfkfZIpgmptBwJeE7DlWm2","answer":"!F(!(x4 W (x1 => x2 and x3)) and F(x4) ","explanation":"negating the eventually clause -> this is not true: x4 is true until at least (weak until used here) x1's trueness implies x2 and x3's trueness\n\nthis one was honestly very confusing but i think these line up?"},{"studentID":"XsaC3AijqlTPGgknfTWr9Czhwed2","answer":"x1->x4->x2 AND x3","explanation":"Something being never eventually false means that it is true. x1 being true implies that x2 and x3 are true, but x4 must be true before x2 and x3. So x1 implies x4 which then implies x2 and x3. "},{"studentID":"FedMWmwEd7W3C68gTqm66aRiqns2","answer":"G(!F(x4-> x1 -> x2 and x3))","explanation":"It always will hold that it won't eventually hold that x4 is true will imply that x1 implies that x2 and x3 are true"},{"studentID":"Urx7swvwyjUNbQ9lD233ds11JKJ3","answer":"G(!F(x1->F(x4) U (x2 and x3))","explanation":"Never eventually can be expressed as G(!F(x)) and \"after\" can be expressed with Until."}]},{"prompt":"The variable x1 will be true at least once, but at some point it will never be true again","rationale":"I think it sounds like a pretty powerful logical statement but it isn't that hard to express in LTL","answers":[{"studentID":"DqLJt0Zj9WSlYXNbRSWqy1aCnyf2","answer":"F(x1) and F(G(!x1))","explanation":"\"F(x1)\" enforces that x1 will be true at least once in the future, and \"F(G(!x1))\" enforces that there is eventually a subtrace where all states henceforce set x1 to be false."},{"studentID":"kExUsPs90Caj3ooAw3UTw6JiTYU2","answer":"F(x1) and F(G(!x1))","explanation":"I'm not sure if G is retroactive here or if it means \"from the current state on\". If it's the former, then I think that the above does not describe the prompt, but I'm unsure what would."},{"studentID":"TWeauYjl4mWo4O6eKbArWZz1s4s1","answer":"F(x1) and F(G(!x1))","explanation":"F is eventually true (so x1 will happen at least once), but it will eventually not be true (G means always true); (G of not x1)"}]},{"prompt":"When x1 is true, then x3 will become true eventually after x2 is true","rationale":"This question kind of represents the situation of a traffic light. when it is green, it will become red after it is yellow.","answers":[{"studentID":"M513vZuSvAWfeOE0WZ7NWBieayn1","answer":"x1 -> (x2 -> F(x3))","explanation":""},{"studentID":"7YpZ1Wx49VhhkqMHvH1TZC9HKEz1","answer":"G((not x1) v X((not x2) U x3))","explanation":"The \"G\" makes the inner formula global, so that whenever \"x1\" is true, \"X((not x2) U x3)\" will be true. The latter means that, starting in the next state, x2 will be false for some non-zero number of states followed by a state where x3 is true."},{"studentID":"qMF6ehxbIhSGK4673vpXIDWqRk92","answer":null,"explanation":null},{"studentID":"0YnVb35gVyZjh40kz442E1Z1mli1","answer":null,"explanation":null},{"studentID":"Urx7swvwyjUNbQ9lD233ds11JKJ3","answer":"x1 => x2 U F(x3)","explanation":"\"U\" can be used to express \"after\""},{"studentID":"ehCdx7swHhPf72JGATgbRZ2e7rs1","answer":"x1 -> x2 U F(x3)","explanation":"when means if. after means U."}]},{"prompt":"It always holds that if x1, then x3 precedes x2 ","rationale":"I think it is interesting, as it defines global precedence rules given some initial condition holds (x1)","answers":[]},{"prompt":"trace of x1 is repeated with with the period of 5 (x at time t+5 will always be x at t)","rationale":"This seems like an interesting way to model oscillation which might be useful when we have a bit that flip after certain time.","answers":[{"studentID":"ehCdx7swHhPf72JGATgbRZ2e7rs1","answer":"x1 => (x1=","explanation":"Sorry I have no idea how to represent x at time t and x at time t + 5."},{"studentID":"mhnr5IV9YdS7voOl3kwhPQJ3bcn1","answer":"x1 => X(X(X(X(X(x1)))))","explanation":"Whatever x1 is at its starting point, the status 5 times later is the same."},{"studentID":"7YpZ1Wx49VhhkqMHvH1TZC9HKEz1","answer":"G(((not x1) v XXXXx1) ^ (x1 v XXXX(not x1)))","explanation":"The \"G\" means that in any state, the inner formula is true. The inner formula is a bi-implication. Therefore in any state, if \"x1\" is true, then the next-next-next-next (i.e. fifth) value of x1 will be true, and vice versa."},{"studentID":"Olm3iZ1G75hC3g8kxg51POXFM402","answer":"x1 & X(x1) & XX(x1) & XXX(x1) & XXXX(x1)","explanation":"Just in the following 5 states, x1 will be true"},{"studentID":"o4OspE6hSFUWj93icU8e3H220fm1","answer":"G(X(X(X(X(X(x1)))))) and x1.","explanation":"Each X represents one state ahead of time t. With 5 X's, I'm representing t+5. And then I have plain x1 for the initial condition at time 0. "},{"studentID":"2uAPcLiTl6S6lkVxb49jwVczlXD2","answer":"F(x1 ∧ N(N(N(N(N(x1))))))","explanation":"Still can't figure out the explicit time step, so using eventually "},{"studentID":"p81246jCdnf8jPP6ckaxgaA9ceB3","answer":"XXXXX(x1)* \\/ XXXXX(-x1)","explanation":"x1 can be false for every five time periods or x2 can be true for every five time periods."},{"studentID":"1PfpKQ5FbSaFVpjLU0zEvi2Vsni2","answer":"G(X(X(X(X(x1)))))","explanation":"This means in words that it is always the case that the next next next next state is x1"},{"studentID":"1utNHrKBy7T4nb34YbOeaMGFzxl1","answer":"G(x1) => X(X(X(X(X(x1)))))","explanation":"x1 is always true implies that, 5 steps from now, x1 will be true."},{"studentID":"yqAbP1hwmpWXnQQRHWGW0uOlRPB3","answer":"X(X(X(X(X(x1)))))","explanation":"I use 5 X operators to indicate the period of 5, with x1!"},{"studentID":"Iwmu1MjrCwcLIRbtZ2likbd2krr2","answer":"G(x1<->XXXXXx1)","explanation":"By definition, it means it is always that current state x1 would be exactly the same with the x1 5 states after. "},{"studentID":"XXDQ67q4UiSR2kFxVzhaxL1hRZC3","answer":"G(x1 => X(X(X(X(X(x1))))))","explanation":""},{"studentID":"WAQ3dKACLtX8yKwCEVHHryA0JWz1","answer":"x1 => X(X(X(X(X(x1))))) and !x1 => X(X(X(X(X(!x1)))))","explanation":"if x1 is true then five nexts, x1 is true again. But if its false, then its false 5 later"}]},{"prompt":"Make x2 hold in any and only those states which come after the last state in which x1 holds.","rationale":"I think the notion of the last state in which something holds is an interesting idea. With our version of LTL, we usually think of forward flowing time and the start of things, but this gets at the other side of time, looking backwards from the end. It doesn't require a very complicated formula, but it isn't something that directly translates into LTL just from the language, and does require some amount of thinking to come up with.","answers":[{"studentID":"g189tDKZqyfaI2GiXyXWcUWilJB2","answer":"G ((x1 && (X G ~x1)) => X G x2)","explanation":"We require that for all states, if there is a state where x1 holds in that state but not in any (G) following (X) states, then x2 holds for all (G) following (X) states."},{"studentID":"AxWttnGXbFOGMdMAoOcSQHoPFuB2","answer":"G(x1 => x2)","explanation":"The any and only idea was a bit confusing. The G means that all traces should hold  that implication, which should allow for sequences where they both evaluate to false, completing the \"only\" idea of the statement."},{"studentID":"CUpKAZiiOrMlB7VEhcBrcxBDduN2","answer":null,"explanation":null},{"studentID":"FK5jY3NfsvSIHK38KFpV6g8dFak1","answer":"x1 ^ G~x1 --> XGx2","explanation":"x1 ^ G~x will only be true for the last state where x1 holds true\nx1 ^ G~x1 --> XGx2 if x2 is always true after the last state where x1 holds true"},{"studentID":"R94tBoHz8ySNViJBvSke3qpd7N03","answer":"G(x2 => G(!x1))","explanation":"Whenever x2 is false, then we can allow x1 to be anything. If x2 is true, then x1 must be false in this state and thereafter."},{"studentID":"fRdxvbOnDTSVL5Ps9hTMqWSV5gc2","answer":"F(x1 U G(!x1 and x2))","explanation":"G(!x1 and x2) means there will be a time where x1 is always false and x2 is always true. x1 U means this time comes after x1 stops being true. F() means this must happen eventually."},{"studentID":"3C5iQZrpLIPHa4l0KSVRUYUAeYn2","answer":" ((x2 U x1)^(x1 U x2))","explanation":"'in any and only' is 'if and only if', so we can rewrite the english sentence as \n'x2 holds until x1 holds' and 'x1 holds until x2 holds'\n\nU is 'the right hand side holds until the left hand side holds', so x2 U x1 is \nx1 holds until x2 holds\n\nso we have \n(x1 U x2)^(x2 U x1)"},{"studentID":"mhnr5IV9YdS7voOl3kwhPQJ3bcn1","answer":"x1 UNTIL (F(!x1 and x2))","explanation":"after x1 is no longer true, utilize the UNTIL, and say in a future state x1 is no longer true and x2 is true"},{"studentID":"XXDQ67q4UiSR2kFxVzhaxL1hRZC3","answer":"G(F(x1) U x2)","explanation":""},{"studentID":"da61uKxwS4RS8uLw9e5aDhx9AAG2","answer":"x1 U x2","explanation":"x1 must be true until x2 occurs (x2 can't occur before).  Since we are starting with x1, x2 will not be true until after the last state in which x1 holds"},{"studentID":"Q6pogKCIaSh3uEueQnutSSKaDw33","answer":null,"explanation":null},{"studentID":"u5LtkhMrVVVNvSHlNyzDQIjuWQl2","answer":"x1 -> X(x2)","explanation":"If x1 holds at some state, then x2 holds starting at the next state"},{"studentID":"uq5XAODUszU4PMKhfbmC0y7kdlO2","answer":"G((x1 and !x2) U (!x1 and x2))","explanation":"By doing (x1 and !x2) U (!x1 and x2)), I ensure that x1 holds and x2 doesn't until the point where they \"switch\". By making this always true, x2 only holds in the states after x1 no longer holds."},{"studentID":"xnwt9vlgrKQMCMF8UkHGCLYNOxw2","answer":"x1 -> F(x2)","explanation":"If x1 is true, it implies that eventually (F), x2 is true. I am assuming that \"eventually\" is similar to \"any and only those states which come after a state\")."},{"studentID":"79DF8m2XmUOKjV8Ob9evefRWNHw1","answer":"G(x2 and !x1) and G(x1->!x2)","explanation":"it always holds that x1 implies not x2. \nwhen x2 then not x1. "},{"studentID":"5oLl7ZPijNYyMSwp55PwKSehzRq1","answer":"(x1 /\\ ~x2) U G(~x1)","explanation":"x2 can only occur after the last x1, so x1 and not x2 has to hold up until a point, after that point x1 must be false (since the point is after the last state in which x1 holds) and x2 could be anything since it could hold in any or none of the states that follow, it just cant hold until after the last x1."},{"studentID":"Olm3iZ1G75hC3g8kxg51POXFM402","answer":"(x1 U !x1) -> x2","explanation":"Let x1 be true until it becomes false, then the x2 will be true"},{"studentID":"UJYax3ztBqcD2acHhEY8qP4lBhG3","answer":"x2 W (x1 and x(G(!x1)))","explanation":"Another use of the weak until operator. x1 must be true and, from the next state on, globally false"},{"studentID":"DfrktEsV96QCmKYSnC1SkAZ92Jm1","answer":"~x2 U (x1 and X(G(~x1 and x2))","explanation":"not x2 holds until some point where x1 holds, but it never does again and x2 always does after"},{"studentID":"zKquIv2iqOPUbju84kD6x2oqxQC3","answer":"!x2 U (G(!x1 and x2))","explanation":"x2 must be false until x1 is always false and x2 is always true.  "},{"studentID":"DqLJt0Zj9WSlYXNbRSWqy1aCnyf2","answer":"(x1 and !x2) U (G(x2 and !x1))","explanation":"Until all states set x2 true and x1 false (\"G(x2 and !x1)\"), x1 should be true and x2 should be false (\"x1 and !x2\")."}]},{"prompt":"It always holds that x2 is false if x1 is true and x2 is true if x1 is false in the next state","rationale":"This resembles \"waiting your turn\", so x2 cannot hold while x1 is true but in the next state, if x1 is \"finished\" (false), then x2 is true","answers":[{"studentID":"yqAbP1hwmpWXnQQRHWGW0uOlRPB3","answer":null,"explanation":null},{"studentID":"mkSbSzp0rUQ30XSeUq1F4HqG0S82","answer":"G(x1 => !x2, !X(x1) => x2)","explanation":"This is all in a globally true function: x1 implies not x2 and x1 false in the next state implies x2."},{"studentID":"79DF8m2XmUOKjV8Ob9evefRWNHw1","answer":"G(x1->!x2) and G(X(!x1) -> x2)","explanation":"G(x1->!x2): x1 is true implies that x2 is false \n G(X(!x1) -> x2): the next state after x1 is false is where x2 is true"},{"studentID":"1utNHrKBy7T4nb34YbOeaMGFzxl1","answer":"G(!x2) AND (x1 AND (x2 AND X(!x1)))","explanation":"Used if statements to be represented as parentheses with AND, while only and to be the AND operator."},{"studentID":"QNFbaiaIhcRfRQoHtE9QvXtkhxf1","answer":null,"explanation":null},{"studentID":"rx7fWLw9Uag06VhtzwrPHdWEKuC2","answer":"G((x1 -> !x2) and (X(!x1) -> x2))","explanation":"I wrapped the G (always) around the whole expression, and used X to denote the next state"}]},{"prompt":"when x1 is true, x2 will eventually (but not immediately) be true","rationale":"While answering questions I had to google a lot of things and I ended up on this caltech powerpoint that made more sense to me so I spent some time with that--they had a cool example about traffic lights that I didn't see represented in the 10 questions I answered but seemed relevant, where there is some mandatory resting time between steps, so the formula cannot allow immediate change","answers":[{"studentID":"9FWl8IytHMMyyETmCpMUJijdoEj2","answer":"x1 -> X(!x2) and F(x2)","explanation":"if x1 is true then in the next state x2 has to be false but eventually, it will be true."},{"studentID":"yavIxXSH3vfpUlXFgyEZ39leNop2","answer":"x1 => (X(!x2) and F(x2))","explanation":"\"when\" is handled by implication, X(!x2) handles \"not immediately\" and F(x2) makes x2 eventually true."},{"studentID":"1utNHrKBy7T4nb34YbOeaMGFzxl1","answer":"x1 => F(x2)","explanation":"F represents eventually, and the two expressions are connected by implies."},{"studentID":"n6X9W01WPlSOMef0b3WU2WBmqVC2","answer":"x1 -> F(X(x2))","explanation":"x2 will eventually be true after next state"},{"studentID":"XKjYJO7zc0dP1NfMtzP4jbagTLR2","answer":"G(x1 => F(x2) and X(!x2))","explanation":""},{"studentID":"oHfP2KoEE8PHFh9JpFBlrT9FonJ2","answer":"x1 => x2! and F(x2) ","explanation":"x1 being true implies that x2 will eventually be but, currently it is false."},{"studentID":"kd663bJTz0hO7SfexfzikeYZgj53","answer":null,"explanation":null}]},{"prompt":"x1 starts true and is true exactly every third state","rationale":"Not directly translatable to LTL syntax, requires clever interpretation","answers":[{"studentID":"uq5XAODUszU4PMKhfbmC0y7kdlO2","answer":"x1 and XXX(x1)","explanation":"Again, I feel bad just using X, because i feel like when we \"advance\" the modulus gets reset? But that could be wrong."},{"studentID":"Iwmu1MjrCwcLIRbtZ2likbd2krr2","answer":"Undoable","explanation":"I don't think this is doable in LTL. Because LTL lacks some mechanics on checking multiples. "},{"studentID":"n6X9W01WPlSOMef0b3WU2WBmqVC2","answer":"x1 -> (X(¬x1) ^ X(X(x1)))","explanation":""},{"studentID":"eaIqaTs5sLTe88iSf2SdfYFDqPs2","answer":"x1 and X(!x1) and G(x1 <=> X(X(x1)))","explanation":""},{"studentID":"1utNHrKBy7T4nb34YbOeaMGFzxl1","answer":"x1 AND X(X(X(x1)))","explanation":"x1 is true when its third state is true."},{"studentID":"UJYax3ztBqcD2acHhEY8qP4lBhG3","answer":"x1 and G(x1 U X(!x1 and X(!x1 and X(x1))))","explanation":"The initial x1 ensures that the loop starts with it true. The second "},{"studentID":"2xb6qACusvPKldc9LfV1mfG35gz1","answer":"No answer","explanation":"I am  unsure how to specify every third state."},{"studentID":"qsvPOzEQ1NeTrWs1iQmcqVOTHOJ3","answer":"x1 and G(X(X(X(x1))))","explanation":"G(X(X(X(x1)))) ensures that every third state is true, x1 ensures that the first state is true"},{"studentID":"Mvw9fmUXFgVJjg6w1CCDcTkBdJo2","answer":"x1 and (x1 implies X(X(X(x1))))","explanation":"x1 is true now and x1 being true implies that x1 is also true in the next, next, next state"},{"studentID":"Wy5fyfEMa6cPDN3JzFAmXgbXvaw2","answer":null,"explanation":null},{"studentID":"ZdXWZhb3FQamAIjPsR8DFsmHhwe2","answer":"XXXx1","explanation":"I am not really sure how to express \"every third state\" but I imagine it is using next in some way"},{"studentID":"YZmWKZlgaZOrzGYNRp4TUVv5pZ13","answer":"G(x1 => (X(not(x1)) and X(not(x1) and X(x1)) ","explanation":"I think  that my expression describes a kind of \"recursive\" state, where x1 implies the sequence of \"next\" states not(x1) and then not(x1) and then x1. And since I wrapped this in a \"global\", the last state, x1 being true, would imply that this sequence of states is repeated."},{"studentID":"xnwt9vlgrKQMCMF8UkHGCLYNOxw2","answer":"(x1 |= true)  AND (G^(=3)(x1 |= true))","explanation":"(x1 |= true) means that x1 is true and (G^(=3)(x1 |= true)) means that x1 is always true every third state."},{"studentID":"XKjYJO7zc0dP1NfMtzP4jbagTLR2","answer":"x1 and G(x1 => X(!x1) and X(X(!x1)) and X(X(X(x1))))","explanation":""},{"studentID":"R94tBoHz8ySNViJBvSke3qpd7N03","answer":"x1 and X(!x1) and X(X(x1)) and X(G((!x1 and X(!x1) and X(X(x1))) or (!x1 and X(x1) and X(X(!x1))) or (x1 and X(!x1) and X(X(!x1))))","explanation":"The first part is first, second, and third state. After that we ensure that the variable is true  exactly every third state (starting at the second state)."},{"studentID":"yLK6W8nyVrMUkNMyxFYLNsJdaPt2","answer":"x1 and G(X(X(X(x1))","explanation":"So since x1 starts true that is why I put just x1. I was very confused at how to say \"exactly every third state\" and I wasn't able to get any suggestions from lecture or my question on Piazza by the time I needed to do this, so I know that X refers to the next state so I thought by putting it inside G, which means that the expression always holds, that x1 in the next next next state would always be true, which I think somewhat similar to saying every third state. "},{"studentID":"g189tDKZqyfaI2GiXyXWcUWilJB2","answer":"x1 && G (x1 => ((X ~x1) && (X X ~x1) && (X X X x1)))","explanation":"I achieved this by stating that, for all states, whenever x1 is true it must be followed by the sequence ~x1, ~x1, x1. Requiring the final x1 state ensures that the pattern will repeat without spaces between repeats, and ensuring that the first state has x1 true (with the x1 && ...) ensures the cycle will start."}]},{"prompt":"x2 is always true, whereas x1 is only sometimes true. ","rationale":"This seems like a simple question, but I think the trickiest thing for me, with LTL, is how to express individual states being true vs. a state always being true (whereas the idea of temporal succession seems pretty clear to me). So I wanted to write a question with a fairly simple concept that would elucidate this difference.","answers":[{"studentID":"mhnr5IV9YdS7voOl3kwhPQJ3bcn1","answer":"G(x2) U (x1 U !x1)","explanation":"Because x2 is always true, it is nested in G, and the state of x1 does not depend on x2 so the expressions are union'ed. "},{"studentID":"Mvw9fmUXFgVJjg6w1CCDcTkBdJo2","answer":null,"explanation":null},{"studentID":"qMF6ehxbIhSGK4673vpXIDWqRk92","answer":null,"explanation":null},{"studentID":"j2h7kE6TUTe8mOHJ8n2gWkGvi922","answer":"G(x2) and F(x1)","explanation":"G(x2) means x2 is always true and F(x1) means that x1 is eventually true somewhere in the trace"},{"studentID":"DfrktEsV96QCmKYSnC1SkAZ92Jm1","answer":"G(x2) and F(x1)","explanation":"G(x2) means x2 is true at each state, while \"sometimes true\" means there is at least one state where x1 is true, so F(x1)"},{"studentID":"XXDQ67q4UiSR2kFxVzhaxL1hRZC3","answer":"G(x2)∧¬G(x1)","explanation":""},{"studentID":"yLK6W8nyVrMUkNMyxFYLNsJdaPt2","answer":"G(x2) and F(x1)","explanation":"G means that the expression always holds, which is why I put x2 inside of G since it must always be true. Since x1 is only sometimes true, this is essentially the same thing as saying that x1 will eventually be true, which is expressed by using the F symbol and hence why I included x1 inside of F.  "},{"studentID":"yavIxXSH3vfpUlXFgyEZ39leNop2","answer":"G(x2) and F(x1) and F(!x1)","explanation":"x1 has to be true sometimes and false sometimes. This is expressed via F(x1) and F(!x1). x2 is always true is expressed by G(x2). "},{"studentID":"SX5qjuY4LhdUlbePO48FvB797G53","answer":"G(x2) and F(x1) and F(-x1)","explanation":"x2 is always true, and for some trace steps i and j, x1 will be true at i and false at j."},{"studentID":"WAQ3dKACLtX8yKwCEVHHryA0JWz1","answer":null,"explanation":null},{"studentID":"UKl2qkKWlKO6BQ9PwxsbdegpkDV2","answer":"w ⊨ G(x2)\nw ⊨ F(x1)","explanation":"x2 is always true so at any point in trace w, x2 should be satisfied, which means that forall i, w^i ⊨ x2, so we have w ⊨ G(x2).\nx1 is only sometimes true, which means that it must be true at some point, so there exists an i such that w^i ⊨ x1, so we have w ⊨ F(x1)."},{"studentID":"1utNHrKBy7T4nb34YbOeaMGFzxl1","answer":"G(x2) U ((x1 U !x1) AND (!x1 U x1))","explanation":"G was used to represent always, while U represents sometimes / whereas."},{"studentID":"0HC3dpmLyKeoD74DguNF8DNwqrj1","answer":"G(x2) ∨ x1","explanation":"G is always. the ∨ allows for an inclusive or that accounts for cases where x1 may be true, but may be false"},{"studentID":"VcwHvUABF3hqOeJni9XH0HFRNwJ2","answer":"G(x2) and F(x1)","explanation":""},{"studentID":"oHfP2KoEE8PHFh9JpFBlrT9FonJ2","answer":"G(x2) and F(x1)","explanation":"G means something is always true (x2) and F means it eventually will be"}]},{"prompt":"It is always the case that x1 happens immediately before x2.","rationale":"It needs to use both G and X and to represent implication using not and or.","answers":[{"studentID":"LAeoyaF0twbF0V1g5eQ2GEPsxJE2","answer":"G(((~x1) /\\ ~X(x2)) \\/ (x1 /\\ X(x2)))","explanation":"Two cases corresponding to x1 happen or not."},{"studentID":"79DF8m2XmUOKjV8Ob9evefRWNHw1","answer":"G(x1 -> X(x2)) ","explanation":"I am assuming here that x1 in a state i, while X(x2) gives me that state after the one where x1 is set to true."},{"studentID":"XKjYJO7zc0dP1NfMtzP4jbagTLR2","answer":"G((x1 => X(x2)) and (!x1 => X(!x2))","explanation":"Whenever x1 is true, x2 is true in the state after that; whenever x1 is false, then x2 cannot be true in the state after."},{"studentID":"kOYh8lB1WQhEgx5Pte67U4XSnE93","answer":"G( x1 and Xx2)","explanation":"I am assuming that 'happens' is a boolean that means true, and 'not happens' is false. Thus, it will always happen, hence I use the G."},{"studentID":"DfrktEsV96QCmKYSnC1SkAZ92Jm1","answer":"G(~x1 or X(x2))","explanation":"for any state, if x1 is true, at the next state x2 is true"},{"studentID":"3C5iQZrpLIPHa4l0KSVRUYUAeYn2","answer":"G(~x1 v X(x2))","explanation":"I honestly don't know how to write 'next timestep' in LTL so I'm using X here which probably is wrong.\nThe rest of the statement is that\nIt is always true(G) that after x1 happens, x2 happens\nso if x1 doesn't happen ~x1 would evaluate to True\nbut when x1 happens, x2 should evaluate to true at the next time step"},{"studentID":"QNFbaiaIhcRfRQoHtE9QvXtkhxf1","answer":"x2 U x1 ","explanation":"Saying that x1 happens immediately before x2 is like saying that x2 happens immediately after x1. If we define \"happens\" as becoming true, then the above says that x1 doesn't become true until x2 does."},{"studentID":"uq5XAODUszU4PMKhfbmC0y7kdlO2","answer":"G(x1 => X(x2))","explanation":"I feel like I'm missing something for this - what does \"happens\" mean?"},{"studentID":"kd663bJTz0hO7SfexfzikeYZgj53","answer":"G(x1 <=> Xx2)","explanation":"It's globally true that x1 iff x2 in the next state"}]},{"prompt":"x3 is always true if x1 and x2 are true in the previous state.  x3 will eventually be true.","rationale":"This can be answered in two ways:\nG((x1 and x2) => Xx3) and F(x3) (direct interpretation)\nor, G((x1 and x2) => Xx3) and F(x1 and x2) (building off G((x1 and x2) => Xx3), F(x1 and x2) => F(x3))\n\nIt is interesting to see how your LTL statement can rely on itself to get its message across.","answers":[{"studentID":"79DF8m2XmUOKjV8Ob9evefRWNHw1","answer":"G((x1 and x2) -> X(x3))\nF(x3)","explanation":"It always holds that if x1 and x2 is true in a specific state (x2 and x2). then in the next state x3 is true (X(x3)). "}]},{"prompt":"For x1, x2, and x3, if a variable is true, it will remain true until all variables are true; after which all variables will be false.","rationale":"I found this interesting to think about because it represents consensus. All variables can return to the false state only if all variables become true. I also had a tough time thinking about the LTL formula for this description. ","answers":[]},{"prompt":"Write a trace that describes that if it at least rains once, or on alternating days, (rain being the boolean x1), the bean will eventually sprout (x2).","rationale":"I think the interesting part about the instance that I wrote is that I specified that the only way for x2 to be true is for x1 to operate under two conditions -- the existence of x1 being true at some point, or always alternating beforehand, which I think can be fun to think about how to succinctly declare in LTL.","answers":[{"studentID":"0HC3dpmLyKeoD74DguNF8DNwqrj1","answer":"F(x2 U x1)","explanation":"It will eventually (F) hold that x2 is true if there is an entry in the sequence prior to x2 being true where x1 is true."},{"studentID":"9FWl8IytHMMyyETmCpMUJijdoEj2","answer":"F(x1) -> F(x2)","explanation":"If it eventually rains, then a bean will eventually sprout."},{"studentID":"uq5XAODUszU4PMKhfbmC0y7kdlO2","answer":"F(x1 or (!x1 and X(x1)) => F(x2)","explanation":"If it eventually rains, then the bean will sprout"},{"studentID":"0YnVb35gVyZjh40kz442E1Z1mli1","answer":"F(x1) -> F(x2)","explanation":"finally, if x1 occurs, x2 will occur"},{"studentID":"5oLl7ZPijNYyMSwp55PwKSehzRq1","answer":"(F(x1)) U x2","explanation":"If up until a certain point it rains eventually, or at least once, then at that point it switches to the second part being satisfied, or x2 being true. If it rains on alternating days then it has also rained at least once so the minimum condition for making the bean sprout is that it rains at least once."},{"studentID":"UKl2qkKWlKO6BQ9PwxsbdegpkDV2","answer":"w ⊨ (F(x1) ⟹ F(x2))","explanation":"First we need to express that it rains at least once or on alternating days. Luckily, since it can't rain on alternating days without first raining at least once, we need to say that it rains at least once. So, there exists an i such that w^i ⊨ x1, which is F(x1). Then, we need to show that the bean will eventually sprout i.e. there exists an i such that w^i ⊨ x2, which is F(x2). We then need the implication that if it rains the bean will eventually sprout, so we have w ⊨ (F(x1) ⟹ F(x2))."},{"studentID":"1PfpKQ5FbSaFVpjLU0zEvi2Vsni2","answer":null,"explanation":null},{"studentID":"M513vZuSvAWfeOE0WZ7NWBieayn1","answer":"F(x1) or ((x1 -> X(!x1)) and (!x1 -> X(x1)))   => F(x2)","explanation":"not sure if the alternating is necessary"},{"studentID":"Urx7swvwyjUNbQ9lD233ds11JKJ3","answer":"F(x1) ^ F(x2)","explanation":"If it rains, then the bean will eventually sprout."},{"studentID":"WLnzJgg9usPE4u8WLnHafylGsSq1","answer":"(F(x1) /\\ F(x2)) \\/ G(~x1)","explanation":"sometimes x1 and sometimes x2 or never x1."},{"studentID":"WAQ3dKACLtX8yKwCEVHHryA0JWz1","answer":"x1 or (x1 and X(!x1)) => F(x2)","explanation":"I have no idea what this is asking to be honest. x1 means that if it rains the or means that it rains or (x1 and X(!x1)) is true which means that it rains one day and not the next. If either of those predicates are true then F(x2) is true which means eventually the bean sprouts"},{"studentID":"5IPmn9xCANgNuM7LIh9zG4wqqQc2","answer":"(x1 or G((x1 => X(!x1)) and (!x1 => X(x1))) => F(x2)","explanation":"Starting with the second half of the sentence, we can express the bean eventually sprouting using the F operator: F(x2). For the first half, the bare variable x1 represents it raining at least once (I think), while we express rain happening on alternate days using the formula (x1 => X(!x1)) and (!x1 => X(x1)). This means that rain happening on one day implies no rain on the next days, and vice versa. We wrap this in a G operator to say that this pattern is always the case."}]},{"prompt":"whenever x1 is true, x2 will be true at some point in the future","rationale":"This is a question that Tim thought would be interesting.","answers":[{"studentID":"kExUsPs90Caj3ooAw3UTw6JiTYU2","answer":"G(x1 => F(x2))","explanation":""},{"studentID":"fRdxvbOnDTSVL5Ps9hTMqWSV5gc2","answer":"G(x1 -> F(x2))","explanation":"It is always true that if x1 being true means that x2 must eventually become true. F(x2) means x2 eventually becomes true. x1 means x1 is true. -> means implies. G() means always."},{"studentID":"Wy5fyfEMa6cPDN3JzFAmXgbXvaw2","answer":"G(x1 -> F(x2))","explanation":"\"x2 will be true at some point in the future\" interpreted as \"x2 will eventually become and stay true\""},{"studentID":"XsaC3AijqlTPGgknfTWr9Czhwed2","answer":"x1 <-> F(x2)","explanation":"This is my answer because their is a bi-implication between x1 being true and x2 eventually being true. x1 being true can be expressed simply as x1, bi-implication can be expressed as \"<->\", and x2 eventually being true can be expressed as F(x2). "},{"studentID":"2xb6qACusvPKldc9LfV1mfG35gz1","answer":"G(x1 => F(x2))","explanation":"F(x2) is true if x2 is true at some point in the future. We want this if x1 is true."},{"studentID":"FJ1gcCB1SMXfbX4ehcXzcYHcs7l1","answer":"G(x1 => X(F(x2)))","explanation":"This is a condition that we want to always hold (G). Specifically, we want it to hold when x1 is true (x1 =>). When that is the case, we want x2 to be true eventually (F(x2)), but specifically in the future (X(F(x2))). This discounts x2 being true in the world in which x1 is true."},{"studentID":"XKjYJO7zc0dP1NfMtzP4jbagTLR2","answer":"G(x1 => F(x2))","explanation":"whenever necessitates G"},{"studentID":"LAeoyaF0twbF0V1g5eQ2GEPsxJE2","answer":"G(~x1 \\/ F(x2))","explanation":"Straightforward."},{"studentID":"qsvPOzEQ1NeTrWs1iQmcqVOTHOJ3","answer":null,"explanation":null},{"studentID":"R94tBoHz8ySNViJBvSke3qpd7N03","answer":null,"explanation":null},{"studentID":"FRxTfpBnCXSBY762KVw7F5DTJ0r1","answer":"G(x1 -> F(X(x2)))","explanation":"It is always the case that x1 implies x2 will eventually be true in the future"},{"studentID":"YzyRkeE37AhpGTSNU8zVMBwEojl1","answer":"x1 -> F(x2)","explanation":"x1 implies that x2 will eventually be true (F function)"},{"studentID":"WLnzJgg9usPE4u8WLnHafylGsSq1","answer":null,"explanation":null},{"studentID":"UJYax3ztBqcD2acHhEY8qP4lBhG3","answer":"G(F(x1 U X(F(x1))))","explanation":"x1 must be true \"in the future\", so its eventually is wrapped in a next"},{"studentID":"SXuWPt2DVGRMnfN2ELdVux2pv9j2","answer":"G(x1 => F(x2))","explanation":"whenever x1 is true = G(x1 => ...), x2 will be true at some point in the future = F(x2)"},{"studentID":"lRaLOybCkkdkd88UUN9jWGgL9fB3","answer":"G(x1 -> X(F(x2)))","explanation":"Whenever translates to G, and I used X(F(x2)) to get at the strictly in the future notion that seems to be implied"},{"studentID":"yLK6W8nyVrMUkNMyxFYLNsJdaPt2","answer":"x1->F(x2)","explanation":"Whenever is somewhat similar to saying if then, which is represented by using the arrow (->). Since F means eventually, that is why I put x2 inside of it because the question said that it would eventually be true. When this is taken together, I then get the answer I have written above. "},{"studentID":"CUpKAZiiOrMlB7VEhcBrcxBDduN2","answer":"G(x1 -> F(x2))","explanation":"G means that this implication is always true, the implication is x1 is true implies eventually (F) x2 is true"},{"studentID":"AAzmbLYzxbcuw8WEJsNweNOfr542","answer":"G(x1 implies Fx2)","explanation":"It is globally true that if x1 then eventually x2"},{"studentID":"u5LtkhMrVVVNvSHlNyzDQIjuWQl2","answer":"x1 -> F(x2)","explanation":""},{"studentID":"eaIqaTs5sLTe88iSf2SdfYFDqPs2","answer":"G(x1 => F(x2))","explanation":""},{"studentID":"VXpluGJOfOUe37IfyjNfFz3GymV2","answer":"x1 -> F(x2)","explanation":""},{"studentID":"2uAPcLiTl6S6lkVxb49jwVczlXD2","answer":"G(x1 => F(x2))","explanation":"just realized we can use the implies operator, messed up some previous questions. this one is pretty straight forward. "},{"studentID":"T4nr7nKQtkexYyVAi3NwCSqKC5n2","answer":"x1 -> F(x2)","explanation":"if x1 is true, x2 is true at some point after"}]},{"prompt":"If x1 is true, then x2 must have just transitioned from true to false.","rationale":"Expected LTL: G (X x1 => (x2 && X ~x2))\n\nI think this is interesting because it seems that LTL is oriented towards talking about \"this occurs after this\" relationships between states, as opposed to \"this occurs before this,\" so it's easier to transcribe the former into LTL. This expression describes an event being predicated on a previous event, which requires you to change perspective a lit bit to fit in to the LTL model. Specifically, in LTL you need to consider the first state of interest instead of the final state, so that you can use LTL to specify what subsequent states look like (because LTL has no \"look backwards in time\" operator).","answers":[{"studentID":"Olm3iZ1G75hC3g8kxg51POXFM402","answer":"X(x1) -> (x2 & X(!x2))","explanation":"Use the next state of x1 and then it implies that x2 is true and the next state of x2 is false"},{"studentID":"1PfpKQ5FbSaFVpjLU0zEvi2Vsni2","answer":null,"explanation":null},{"studentID":"5IPmn9xCANgNuM7LIh9zG4wqqQc2","answer":"X(x1) -> (x2 and X(!x2))","explanation":"I'm a little confused about this one since I'm a little unclear on the concept of previous states in LTL, which seems necessary for the second half of the sentence. To handle this I decided to start with x1 being true on the NEXT state, i.e. X(x1). This implies that x2 is true and also X(!x2), which I think translates to x2 being true on the previous state and false on the state after that (i.e. x2 transitioning from true to false)."},{"studentID":"XKjYJO7zc0dP1NfMtzP4jbagTLR2","answer":"(x2 U x1) and G(x2 and !x1)","explanation":"x2 must be true until x1 is true, and x1 is false when x2 is true"},{"studentID":"yqAbP1hwmpWXnQQRHWGW0uOlRPB3","answer":null,"explanation":null},{"studentID":"LKGb8fPfkfZIpgmptBwJeE7DlWm2","answer":"X(x1) => x2 and X(!x2)","explanation":"by using next, we are able to get this idea of previous - if after removing t0 then x1 is true then x2 must have been true in the now (which to the next is the previous) and x2 is false in the next"},{"studentID":"YzyRkeE37AhpGTSNU8zVMBwEojl1","answer":"x1 -> x2 U !x2 ","explanation":"The u function is for the transition from true to false, and x1 being true implies that must be true"},{"studentID":"WAQ3dKACLtX8yKwCEVHHryA0JWz1","answer":"G(X(x1) => (x2 and !X(x2)))","explanation":"G means always true. X(x1) means true in the next state, and if its true the in the current state x2 is true and the next x2 is false"},{"studentID":"o4OspE6hSFUWj93icU8e3H220fm1","answer":"G(X(x1) => (!x2 and X(x2)))","explanation":"I'm interpreting an implicit global scope here, since without it the interpretation would be the first state, which doesn't make sense because there x2 couldn't have just transitioned from true to false. Since there is no operator for looking backwards, I make the next state X() the 'present' state, and use no operators to express the past state with !x2."},{"studentID":"LAeoyaF0twbF0V1g5eQ2GEPsxJE2","answer":"~x1 /\\ G(~X(x1) \\/ (x2 /\\ ~X(x2)))","explanation":"In the first state, x1 cannot be true. In all states, whenever x1 will be true next, x2 needs to be true in present and false next."},{"studentID":"FK5jY3NfsvSIHK38KFpV6g8dFak1","answer":"Xx1 -> x2 ^ X~x2","explanation":"x2 ^ X~x2 means the transition of x2 from true to false. \nXx1 -> x2 ^ X~x2 (if the next step x, x2 have to transition now)"},{"studentID":"79DF8m2XmUOKjV8Ob9evefRWNHw1","answer":"X(x1) -> (x2 and X(!x2))","explanation":"Consider state 1. If x1 is true then, then x2 was true in state 0 and now false in 1. "},{"studentID":"qMF6ehxbIhSGK4673vpXIDWqRk92","answer":"x1 -> (x2 U !x2)","explanation":"U means transition from true to false"},{"studentID":"AxWttnGXbFOGMdMAoOcSQHoPFuB2","answer":"x1 => !x2","explanation":"The transition idea is confusing, but I think guaranteeing that it will be false through the implies will fulfill the statement."},{"studentID":"k6kvJj5VCUPWLj2ppeOMNVBQzeJ2","answer":"G(  ( !x2 -and X(x2))  ->X( x1)  ) and G(  (x2 and X(!x2) ->X(x1 )) and G(  (x2 and X(x2) ->X(!x1 )) and G(  (!x2 and X(!x2) ->X(!x1 ))","explanation":"\"G(  ( !x2 -and X(x2))  ->X( x1)  )\" says that if x2 went from false to true, then x1 is true. \"G(  (x2 and X(!x2) ->X(x1 ))\" says that if x2 went from true to false then x holds.\n\"G(  (x2 and X(x2) ->X(!x1 )) G(  (!x2 and X(!x2) ->X(!x1 ))\" says that if x2 stayed the same, then x1 is false."}]},{"prompt":"If at some point in time, x1 becomes true and stays true, is it always true that x1 eventually becomes true or is it eventually true that x1 is always true? ","rationale":"This question is meant to help understanding the semantics.","answers":[{"studentID":"3C5iQZrpLIPHa4l0KSVRUYUAeYn2","answer":"''x1 eventually becomes true' is always true' is True\n''x1 is always true' is eventually true' is False","explanation":"case 1: is it always true that x1 eventually becomes true?\nif there exists time i such that x1^j is true ; j>i evaluates to true, then by definition of 'eventually',\n'x1 eventually becomes true' evaluates to True. G(Tautology) is true since Tautology is always true for all i. \ncase 2: is it eventually true that x1 is always true?\n'x1 is always True' evaluates to false since the time i where x1^j is true ; j>i  for all j does not necessarily be 0 and so \nF(contradiction) is always false since it remains False for all time i. \nTherefore, the former is the correct statement"},{"studentID":"o4OspE6hSFUWj93icU8e3H220fm1","answer":"F(x1) implies (G(F(x1) or G(x1))","explanation":"I wrote the formula to the question as if it were a statement, but I believe the actual answer to the question would be that x1 eventually becomes true, or F(x1)."},{"studentID":"p81246jCdnf8jPP6ckaxgaA9ceB3","answer":"F(x1) /\\ X(x1)*","explanation":"I did not really get how to answer the question in LTL but I just encoded the x1 eventually being true and staying true."},{"studentID":"Urx7swvwyjUNbQ9lD233ds11JKJ3","answer":"it is always true that x1 eventually becomes true\nF(x1)","explanation":"There exists an i that for all j >= i, x1 is true."}]},{"prompt":"x1 cannot be true three states in a row","rationale":"\"in a row\" is an interesting concept","answers":[{"studentID":"Z8I0Gua8DxZT3Lr3BGcIfZxlivI2","answer":"G (!( x1 and X(x1) and X(X(x1)) )) ","explanation":"The statement just says that the case in which x1 is true 3 states in a row, is always never true"},{"studentID":"kOYh8lB1WQhEgx5Pte67U4XSnE93","answer":"G( ! (x1 and Xx1 and XXx1))","explanation":"I put a G on the outside to apply it to a rule to all states. Basically, I hard coded that there can't be a case where x1 is true for one state, the state after, and the state after."},{"studentID":"qMF6ehxbIhSGK4673vpXIDWqRk92","answer":"!G(x1)","explanation":"x1 cannot be always true"},{"studentID":"zKquIv2iqOPUbju84kD6x2oqxQC3","answer":"G((x1 and X(x1)) => X(X(!x1)))","explanation":"If x1 is true 2 states in a row, it should be false in the next state."},{"studentID":"uhSgQJpSx7dbcXRJqnQpLJPHK8s1","answer":"x1:=false | ◯ x1:=false | ◯ x1:=false","explanation":"Referencing http://www.cds.caltech.edu/~murray/courses/afrl-sp12/L3_ltl-24Apr12.pdf a LTL syntax resource, I think using ◯ references the next state (not sure how to constraint the next 3 states specifically) so I did next's next's next "},{"studentID":"rkJV8Z8X1ENdbW3Sk2dTT0GsMmn1","answer":"G (¬(x1 ∧ X x1 ∧ XX x1))","explanation":"It is always the case that x1 AND the next x1 AND the next next x1 is false (at least one must be false)."},{"studentID":"CUpKAZiiOrMlB7VEhcBrcxBDduN2","answer":"!F(x1 ^ X(x1) ^ X(X(x1)))","explanation":"There is never eventually a state where (x1) is true, and the next state X(x1) is true, and the next next state X(X(x1)) is true"},{"studentID":"FJ1gcCB1SMXfbX4ehcXzcYHcs7l1","answer":"G(~(x1 ^ X(x1) ^ X(X(x1))))","explanation":"This is a condition that we want to be true at all states (G). We use (x1 ^ X(x1) ^ X(X(x1))) to mean that x1 is true in this state, the next state, and the state after the next state. So, the negation of this says that x1 is not true in all three consecutive states."},{"studentID":"obb14y1buwOu9DPHwVn15COD5Ky1","answer":"G(~(x1 /\\ X(x1) /\\ X(X(x1)) )","explanation":"(x1 /\\ X(x1) /\\ X(X(x1) = current_state x1 and next_state x1 and state_after_next x1\nAdd global operator so that it applies to all states and not the initial state.\nSo every state is not a state where x1 is true and true for the next three states."},{"studentID":"zd3DqHgbJ4chMqRezEqT5W4giFe2","answer":"G(x1 /\\ X(x1) /\\ X(X(x1)))","explanation":""},{"studentID":"j2h7kE6TUTe8mOHJ8n2gWkGvi922","answer":"G( ! (x1 -> X(x1) -> X(X(x1)) ) )","explanation":"x1 -> X(x1) -> X(X(x1)) was my attempt to represent three states in a now where x1 is true. I negate that since I do not want that to be the case and add the G in front as I want this to be the case at any point in the trace"},{"studentID":"u5LtkhMrVVVNvSHlNyzDQIjuWQl2","answer":"!(x1 and X(x1) and X(X(x1)))","explanation":""},{"studentID":"eaIqaTs5sLTe88iSf2SdfYFDqPs2","answer":"G(!x1 or X(!x1) X(X(!x1))","explanation":""},{"studentID":"n6X9W01WPlSOMef0b3WU2WBmqVC2","answer":"x1 -> (X(¬x1) v X(X(¬x1)))","explanation":"X() means next state, X(X()) means next of the next state"},{"studentID":"SXuWPt2DVGRMnfN2ELdVux2pv9j2","answer":"G((x1 and X(x1) => X(X(!x1)))","explanation":"Multiple ways to formulate this one. My interpretation: whenever (G) x1 is true two states in a row (x1 and X(x1)), it is false the following state (X(X(!x1))). This implies it can't be true three states in a row."},{"studentID":"qsvPOzEQ1NeTrWs1iQmcqVOTHOJ3","answer":"G(x1 and X(x1) and X(X(x1)))","explanation":"x1 and X(x1) and X(X(x1))) would only evaluate True if the all three terms of the sequence evaluate to True, the G in front stands that this must always hold."},{"studentID":"da61uKxwS4RS8uLw9e5aDhx9AAG2","answer":"G(x1 -> (X NOT x1) -> (XX NOT x1))","explanation":"if x1 is true, that implies that, in the next state, NOT x2 should be true, and in the state after that (XX), NOT x1 should also be true.  This should be globally true, since it is not necessarily true that x1 will always be true in the first state."},{"studentID":"ZdXWZhb3FQamAIjPsR8DFsmHhwe2","answer":"G(-(XXXx1))","explanation":"I have that it is always not true that x1 is true in 3 states in a row. I believe this is the correct use of X?"},{"studentID":"xnwt9vlgrKQMCMF8UkHGCLYNOxw2","answer":"x1 |= true -> ○¬x1 /\\ ○○¬x1 /\\ ○○○¬x1","explanation":"\"x1|=true\" indicates when x1 holds true. \"->\" means imply (if-then statement). ○¬x1 /\\ ○○¬x1 /\\ ○○○¬x1 is my attempt to show that x1 has to be false for 3 states in a row. \"○\" indicates the next state. I am referring to http://cs.brown.edu/courses/cs195y/2020/pages/pdf/LTL.pdf and http://www.cds.caltech.edu/~murray/courses/afrl-sp12/L3_ltl-24Apr12.pdf in order to write these answers."},{"studentID":"AAzmbLYzxbcuw8WEJsNweNOfr542","answer":"G(x1 AND Xx1 AND XXx1)","explanation":"It is globally true that x1, x1 for the next, and x1 for the next next iteration"},{"studentID":"DfrktEsV96QCmKYSnC1SkAZ92Jm1","answer":"~(F(x1 and X(x1) and X(X(x1)))","explanation":"it is not the case that there is an x1 state such that the successor and successor's successor are also x1"},{"studentID":"1utNHrKBy7T4nb34YbOeaMGFzxl1","answer":"X(X(X(!x1)))","explanation":"Three states in a row can be represented as 3 X's."},{"studentID":"XXDQ67q4UiSR2kFxVzhaxL1hRZC3","answer":"G(x1 ∧ X(x1) =>¬X(X(x1)))","explanation":"the statment is equivalent to\n  for any x1 is true and its next state is true, its next of next state should be false."},{"studentID":"R94tBoHz8ySNViJBvSke3qpd7N03","answer":"G(!(x1 and X(x1) and X(X(x1))))","explanation":"x1 and X(x1) and X(X(x1)) is x1 being true 3 times. G(!(...)) negates and applies always."}]},{"prompt":"The pattern of true and false of x1 in the first 3 entries repeats. ","rationale":"The solution to this can be simple and it generalizes reasonablely nicely for all n. But it requires some thought.\nHere is my solution: G(x1 <=> X(X(X(x1))))","answers":[{"studentID":"LAeoyaF0twbF0V1g5eQ2GEPsxJE2","answer":"(x1 /\\ X(x1) /\\ X(X(x1))) \\/ (~x1 /\\ X(~x1) /\\ X(X(~x1)))","explanation":"Brute force."},{"studentID":"ZdXWZhb3FQamAIjPsR8DFsmHhwe2","answer":"G(x1 -> Xx1 -> XXx1)","explanation":"I am really not sure how to do this one. I believe this has something to do with next but I am not sure how to \"get\" the truth value of x1 at a given step"},{"studentID":"Iwmu1MjrCwcLIRbtZ2likbd2krr2","answer":"(x1 ∧ X(x1) ∧ XX(x1)) || (¬x1 ∧ ¬X(x1) ∧ ¬XX(x1))","explanation":"Due to the fact that x1 in LTL logic represents the initialization state, then if the first 3 entries repeat, it means all first three states are all true or all false."},{"studentID":"XKjYJO7zc0dP1NfMtzP4jbagTLR2","answer":"x1 and G(x1 => X(!x1) and X(X(!x1)) and X(X(X(x1))))","explanation":"I got a nearly identical question earlier; x1 is true in the first state, false in the second and third, and then true again and repeating."},{"studentID":"DziAzopaJDV4Nz8ugZowMZyrf2l2","answer":"(x1 ∧ X(x1) ∧ X(X(x1))) ∨ (!x1 ∧ !X(x1) ∧ !X(X(x1)))","explanation":"x1, X(x1), X(X(x1)) should all be true or all be false"},{"studentID":"rx7fWLw9Uag06VhtzwrPHdWEKuC2","answer":"x1 -> X(X(X(x1))))","explanation":"x1 implies that x1 holds in the first 3 states"},{"studentID":"YZmWKZlgaZOrzGYNRp4TUVv5pZ13","answer":"G(x1 => X(not(x1)) and X(not(x1))) and X(x1))","explanation":"I think that this question is the same as the question above, where x1 is true and then x1 is not true for two states, so my formula is the same as the answer to that question?"},{"studentID":"da61uKxwS4RS8uLw9e5aDhx9AAG2","answer":"G((x1 OR NOT x1) AND (Xx1 OR NOT x1) AND (XXx1 OR NOT x1))","explanation":"x1 can be true or false in the first state, true or false in the second state, and true or false in the state after that.  Each of those things must be repeated globally, hence the ANDs joining the individual clauses"},{"studentID":"M513vZuSvAWfeOE0WZ7NWBieayn1","answer":"G( X(X(x1)) -> ( X(!x1) and x1 ) or X(X(!x1)) -> ( X(x1) and !x1 )","explanation":""},{"studentID":"VcwHvUABF3hqOeJni9XH0HFRNwJ2","answer":"G(Xx1 and XXx1 and XXXx1)","explanation":"I'm not sure how to express a pattern :( "},{"studentID":"Mvw9fmUXFgVJjg6w1CCDcTkBdJo2","answer":null,"explanation":null},{"studentID":"eaIqaTs5sLTe88iSf2SdfYFDqPs2","answer":"G((x1 <=> X(X(X(x1)))) and (!x1 <=> X(X(X(!x1)))))","explanation":""},{"studentID":"yavIxXSH3vfpUlXFgyEZ39leNop2","answer":null,"explanation":null},{"studentID":"9FWl8IytHMMyyETmCpMUJijdoEj2","answer":"x1 and X(!x1) and X(X(x1))","explanation":"Im not completely sure what to put. At first, I interpreted this as alternating true and false but im not entirely sure."},{"studentID":"mhnr5IV9YdS7voOl3kwhPQJ3bcn1","answer":null,"explanation":null},{"studentID":"obb14y1buwOu9DPHwVn15COD5Ky1","answer":"G(x1 <=> x(x(x(x1))))","explanation":"Since the pattern is three states long, for it to repeat, the x1 in the third state after the current state must be the same as the current state."},{"studentID":"SX5qjuY4LhdUlbePO48FvB797G53","answer":"G(x1 iff X(X(X(x1))))","explanation":"The truth value of x1 at step i will be the same as the truth value of x1 at step i+3."},{"studentID":"oHfP2KoEE8PHFh9JpFBlrT9FonJ2","answer":"(x1 and X(!x1) and XX(x1))","explanation":"Confused by what the question is asking but I alternate between x1 being true and false for 3 states by setting the next and next next"},{"studentID":"7YpZ1Wx49VhhkqMHvH1TZC9HKEz1","answer":"G(((not x1) v XXx1) ^ (x1 v not XXx1))","explanation":"The statement inside the \"G\" is meant to represent a bi-implication, saying that, the first state's x1 value should match the next-next (i.e. the third) state's x1 value. Since it is inside \"G\", this should be true for all statements."}]},{"prompt":"If x1 is eventually true, then x2 will be true at some point after. ","rationale":"I think this formula is interesting because it reflects the \"liveness\" properties that we attempted to verify in our mutual exclusion demos from class-- not just checking that all workers will eventually access the shared resource, but adding the caveat that the workers only are able to access the resource (x2) if they request it (x1). ","answers":[{"studentID":"WLnzJgg9usPE4u8WLnHafylGsSq1","answer":"(F(x1) U F(x2)) \\/ G(~x1)","explanation":"x1 is sometimes true until x2 is sometimes true, or x1 is never true."},{"studentID":"kd663bJTz0hO7SfexfzikeYZgj53","answer":"F x1 => F (x1 & x2)","explanation":"finally x1 implies finally x2 and x2"}]},{"prompt":"It always holds that x1 is true until x2 is false and x3 is true","rationale":"This question is good because it makes sure that people have a firm understanding of some of the key parts of an LTL formula, such as always and until, that are needed in order to write more complicated expressions. ","answers":[{"studentID":"2xb6qACusvPKldc9LfV1mfG35gz1","answer":"G(x1 U (!x2 and x3))","explanation":"Need G for \"always holds\". "},{"studentID":"Mvw9fmUXFgVJjg6w1CCDcTkBdJo2","answer":"G(x1 UNTIL (!x2 and x3))","explanation":"The entire formula is wrapped in a \"globally\" operator to mean that whatever is inside always holds, so always, x1 will be true until both x2 is false and x3 is true"},{"studentID":"qMF6ehxbIhSGK4673vpXIDWqRk92","answer":"G(x1 <=> !x2 and x3)","explanation":"double arrow means until"},{"studentID":"oHfP2KoEE8PHFh9JpFBlrT9FonJ2","answer":"G(x1 U (x2! and x3))","explanation":"x1 must always be true until either x2 is false or x3 is true"},{"studentID":"0YnVb35gVyZjh40kz442E1Z1mli1","answer":"G(x1 U (!x2 & x3))","explanation":"It is always x1 is true until x2 is false and x3 is true"},{"studentID":"2uAPcLiTl6S6lkVxb49jwVczlXD2","answer":"(x1,x2,x3)->(x1,¬x2, ¬x3)->(¬x1,¬x2, x3)->(x1,¬x2, ¬x3)->(¬x1,¬x2, x3)->(x1,¬x2, ¬x3)ω ⊢ G(x1 U ¬x2 ∧ x3)","explanation":"In the trace, x1 is true until x2 is false and x3 is true, and this is true at any point in the trace (no matter where you truncate it)"},{"studentID":"OorJbOFV8odzg7bElwAX7qMXKeu2","answer":"G(x1 U (not x2 and x3))","explanation":"I said that always if x1 is true until (not x2 and x3)"},{"studentID":"VXpluGJOfOUe37IfyjNfFz3GymV2","answer":"G(x1 U(!x2 AND x3))","explanation":""}]},{"prompt":"whenever x1 is true, x1 must be false in the future until x2 holds (and x2 will hold at some point in the future)","rationale":"This is a question that Tim thought would be interesting.","answers":[{"studentID":"xnwt9vlgrKQMCMF8UkHGCLYNOxw2","answer":"G(x1-> ○¬x1 U ◊x2->x1)","explanation":"G indicates always (whenever). When x1 is true, in the next state (○), x1 is false until (U) eventually, x2 holds, which implies(->) that x1 is true."},{"studentID":"2xb6qACusvPKldc9LfV1mfG35gz1","answer":"G(x1 => X(!x1 U x2))","explanation":"X refers to future states."},{"studentID":"da61uKxwS4RS8uLw9e5aDhx9AAG2","answer":"x1 -> (NOT x1) U x2","explanation":"x1 being true implies that NOT x2 should be true until (U) we get x2"},{"studentID":"phrbqZWVjcRh1ZJhWZHdh1yEhMZ2","answer":"(x1 => X(!x1 U x2)) and F(x2)","explanation":"F(x2) : means that x2 will hold at some point\nx1 => X(!x1 U x2) : means that starting at the next state, x1 must be false until x2 hold\n"},{"studentID":"AAzmbLYzxbcuw8WEJsNweNOfr542","answer":"x1implies G((NOT x1) U x2))","explanation":"whenever x1 is true, then [...] is equivalent to: if x1 is true, then always [....]. That is: x1 implies G([...]).\n (...) in the future until x2. is (...) until x2. So in this case, NOTx1 until x2. Combining these, my guess is the above."},{"studentID":"rsp3YalY4iYInzJzXy67djOCMdz2","answer":"x1 => F(!x U x2) and F(x2)","explanation":"x1 implies that x1 will be false until x2 and eventually x2"},{"studentID":"Ao8FhZPEPeV6WdP0CYNeEiGGwP52","answer":"G(¬x1 ∨ (¬x1 U x2))","explanation":"This says that for all states, either x1 is not true or x1 is false until x2 is true"},{"studentID":"Q6pogKCIaSh3uEueQnutSSKaDw33","answer":"x1 -> X(G(~x1 -> ~x1 \\/ x2) /\\ F(x2))","explanation":"x1 being true implies that x1 will continue to be false until x2 is true, which will happen"},{"studentID":"uhSgQJpSx7dbcXRJqnQpLJPHK8s1","answer":"(x1:= true -> F(x1:= false U x2:= true))","explanation":"first I used the U symbol for how x2:= true is the point where x1 becomes false, and all this is implied by whenever x1 is true. "},{"studentID":"DziAzopaJDV4Nz8ugZowMZyrf2l2","answer":"G(x1 -> !x1 U x2)","explanation":"always, if x1 is true, x1 remains false until x2 is true"},{"studentID":"FK5jY3NfsvSIHK38KFpV6g8dFak1","answer":"(x1 --> ~x1Ux2)^Fx2","explanation":"Fx2 => x2 will hold at some point in the future\nwhenever x1 hold ~x1 until x2(x1 --> ~x1Ux2)"},{"studentID":"ZdXWZhb3FQamAIjPsR8DFsmHhwe2","answer":"x1 -> F(-x1) U x2","explanation":"whenever x1 is true clues me in that this must be an implication, and then from there -x1 is x1 false in the future until x2 is true"},{"studentID":"rx7fWLw9Uag06VhtzwrPHdWEKuC2","answer":"x1 -> (F(!x1) U x2) and F(x2)","explanation":"x1 being true implies that x1 is eventually false (using F) until (U) x2 holds, which is combined with F(x2) to show it's eventually true"},{"studentID":"lRaLOybCkkdkd88UUN9jWGgL9fB3","answer":"G(x1 -> X(!x1 U x2))","explanation":"G gives us the 'whenever', and I use X to get into the future and U for the 'until x2 holds and will hold at some point'"},{"studentID":"qsvPOzEQ1NeTrWs1iQmcqVOTHOJ3","answer":"F(x1=>X(!x1)) xor (F(x2) => x1) ","explanation":"F(x1=>X(!x1)) states that when x1 becomes true, the next condition states that if x2 becomes true then x1 becomes false. the xor condition ensures that neither can be true at the same time. "},{"studentID":"FJ1gcCB1SMXfbX4ehcXzcYHcs7l1","answer":"G(x1 => X(~x1 U x2))","explanation":"This is a condition that must always hold (G). We want it so that, if x1 is true in a state (hence \"x1 =>\"), then ~x1 holds until x2 holds. This is precisely what (~x1 U x2) does, and we include X in order to say that this condition starts holding in the next state (because its says \"in the future\"). The \"U\" operator already enforces that x2 eventually holds."},{"studentID":"UKl2qkKWlKO6BQ9PwxsbdegpkDV2","answer":"w ⊨ G(x1 ⟹ X(¬x1 U x2) ∧ X(F(x2)))","explanation":"The piece where x1 is false until x2 holds becomes ¬x1 U x2, because this says that for all traces before x2 is true, x1 is false. We need that to be true in the future, so we use X to get the traces starting from the next state. We also need x2 to hold at some point in the future, so we want there to eventually be a state where x2 is true, giving us F(x2), in the future, so we use X again to get X(F(x2)). So, x1 is false until x2 holds and x2 will eventually hold means X(¬x1 U x2) ∧ X(F(x2)). This should be true when x1 is true, so we have x1 ⟹ X(¬x1 U x2) ∧ X(F(x2)), but it should also be true whenever x1 is true, so this implication should hold for all steps in the trace, meaning we have w ⊨ G(x1 ⟹ X(¬x1 U x2) ∧ X(F(x2)))."},{"studentID":"UJYax3ztBqcD2acHhEY8qP4lBhG3","answer":null,"explanation":null},{"studentID":"yavIxXSH3vfpUlXFgyEZ39leNop2","answer":"G(x1 => (!x1 U x2 and F(x2)))","explanation":"\"whenever\" is enforced by G. The until is enforced by U and F(x2) means x2 will hold at some point in the future. "},{"studentID":"Mvw9fmUXFgVJjg6w1CCDcTkBdJo2","answer":"x1 -> F(!x1 UNTIL x2)","explanation":"x1 being true means that there is eventually a position in the path at which x1 is false until x2 becomes true (which will occur under the UNTIL operator)"},{"studentID":"rkJV8Z8X1ENdbW3Sk2dTT0GsMmn1","answer":"G (x1 -> (¬x1 U x2))","explanation":"It is always the case that x1 being true implies x1 must from that point on be false until x2 is true."},{"studentID":"FRxTfpBnCXSBY762KVw7F5DTJ0r1","answer":"G(x1 -> G((X(!x1))U(X(x2))))","explanation":"it is always the case that x1 implies in the future, x1 will always be false until x2"},{"studentID":"mhnr5IV9YdS7voOl3kwhPQJ3bcn1","answer":"(x1 AND F(!x1 UNTIL x2))","explanation":"x1 is AND'ed with the case in the future that x1 is false until x2 holds true, this is because x1's status changes in the future, paralleled with a change in x2."},{"studentID":"CUpKAZiiOrMlB7VEhcBrcxBDduN2","answer":"x1 -> X(!x1) U F(x2)","explanation":"x1 being true implies (->) that the following (X) x1 are false until eventually (F) x2 becomes true"},{"studentID":"T4nr7nKQtkexYyVAi3NwCSqKC5n2","answer":"G(x1 -> not x1 U x2 ^ F(x2))","explanation":"it's always true that when x1 is true, x1 is false until x2 and x2 is true at some point"},{"studentID":"7YpZ1Wx49VhhkqMHvH1TZC9HKEz1","answer":"G((not x1) v ((not x1) U x2))","explanation":"Globally it must be true that, if x1 is true, then to satisfy the formula, x1 must be false until the (first) state (which exists) where x2 is true, which is what \"U\" means."},{"studentID":"eaIqaTs5sLTe88iSf2SdfYFDqPs2","answer":"G(x1 => (!x1 U x2))","explanation":""},{"studentID":"Z8I0Gua8DxZT3Lr3BGcIfZxlivI2","answer":"x1 => (!X(x1) and !X(X(x)) ) and F(x2)","explanation":"\"whenever x1 is true\" means that x1 is implying something, and since both x1 must be false in the future for x2 holds that means both X(x1) and X(X(x1)) must be false. Lastly you must AND this with F(x2) to signify that x2 will hold at some point in the future."},{"studentID":"WLnzJgg9usPE4u8WLnHafylGsSq1","answer":"(x1 /\\ (G(~x1) U x2)) \\/ G(~x1)","explanation":"x1 is true and (x1 is never true until x2 is true) or x1 is never true"}]},{"prompt":"it eventually holds that if x1 is true then x2 is true thereafter","rationale":"This is a question that Tim thought would be interesting.","answers":[{"studentID":"lRaLOybCkkdkd88UUN9jWGgL9fB3","answer":"F(x1 -> X(G(x2)))","explanation":"It eventually holds translates to F. x2 being true thereafter seems to imply strictly in the future, so I translated it to X(G(x2))"},{"studentID":"p81246jCdnf8jPP6ckaxgaA9ceB3","answer":null,"explanation":null},{"studentID":"LAeoyaF0twbF0V1g5eQ2GEPsxJE2","answer":null,"explanation":null},{"studentID":"rkJV8Z8X1ENdbW3Sk2dTT0GsMmn1","answer":"F (x1 -> G(x2))","explanation":"Eventually, x1 being true implies that x2 will always be true from that point on."},{"studentID":"DqLJt0Zj9WSlYXNbRSWqy1aCnyf2","answer":"F(x1 => X(G(x2)))","explanation":"Assuming that \"it eventually holds\" applies to the whole phrase after it, we use the \"F\" formula surrounding the rest of the statement to show that a subtrace exists in the future that satisfies this statement. Then, we want to show that, in this future subtrace, the first state should hold x1 to be true, and then x2 should be true for all states after-- to select the subtrace excluding the \"now\" state, we use the \"X\" formula, and then we use the \"G\" formula to ensure that all states in this subtrace set x2 as true."},{"studentID":"EbUb3Z6acpajSNs7t62nSh5UpGi2","answer":"F(x1) AND (x1 => x2)","explanation":"We break the predicate up into two parts; the fact that x1 holds eventually and that then it implies x2. The eventually is represented by the F; the implication and AND are self-explanatory."},{"studentID":"xnwt9vlgrKQMCMF8UkHGCLYNOxw2","answer":"F(x1 |= true  -> x2 |= true)","explanation":"I am assuming that the eventuality is that of the statement, \"if x1 is true then x2 is true.\" Hence, I put F(whole statement). The symbol \"->\" indicates implies (if-then) and \"|=\" indicates when a value becomes true."},{"studentID":"uhSgQJpSx7dbcXRJqnQpLJPHK8s1","answer":"F(x1 := true  -> x2 := true)","explanation":"Based on the professor's notes, use F() means eventually. Since x2 being true is dependent on x1 being true, I used the implies -> to show that. "},{"studentID":"u5LtkhMrVVVNvSHlNyzDQIjuWQl2","answer":"F(x1->x2)","explanation":"There exists a point such that x1->x2 holds along the path."},{"studentID":"FJ1gcCB1SMXfbX4ehcXzcYHcs7l1","answer":"F(x1 => X(G(x2)))","explanation":"We want the condition to eventually hold (F), so that if x1 is true (x1 =>), x2 is true thereafter (I interpreted that as strictly after, and always, so X(G(x2))). The only time this wouldn't hold is if x1 were always true and we never had an infinite chain of x2 being true."},{"studentID":"SXuWPt2DVGRMnfN2ELdVux2pv9j2","answer":"F(x1 => G(x2))","explanation":"eventually = F, if/then = =>, thereafter = G"},{"studentID":"FRxTfpBnCXSBY762KVw7F5DTJ0r1","answer":"F(x1 -> G(X(x2)))","explanation":"At some point, it will be the case that if x1 is true, x2 is always true in the future"},{"studentID":"AAzmbLYzxbcuw8WEJsNweNOfr542","answer":"F(x1 implies G(x2))","explanation":"Eventually is a key word for F. \nIf x1 is true, then [...] is x1 implies [...].\nx2 is true thereafter is: it is always true that x2 thereafter.  G(x2)"},{"studentID":"SX5qjuY4LhdUlbePO48FvB797G53","answer":"F(x1) => G(x1 => G(x2))","explanation":"If x1 is eventually true, then once x1 is true, x2 will always be true."},{"studentID":"2xb6qACusvPKldc9LfV1mfG35gz1","answer":"F(x1 => X(x2))","explanation":"F gives eventually, X(x2) says that x1 will hold in the future"},{"studentID":"R94tBoHz8ySNViJBvSke3qpd7N03","answer":"F(x1 => X(G(x2)))","explanation":"This is just a direct translation. X is required because of the thereafter."},{"studentID":"kOYh8lB1WQhEgx5Pte67U4XSnE93","answer":"F(x1 X(G(x2))","explanation":"I came to this conclusion because I knew the F should nest the outside. Then, the inside is just x1 being true will say something about x2 in the next state. Specifically, we want an always case that x2 will always be true after."},{"studentID":"o4OspE6hSFUWj93icU8e3H220fm1","answer":"F(x1 => X(x2))","explanation":"I'm not sure if thereafter means the next state, or every state after. My interpretation here is the nexts state, which just constitutes X(). If it were every state after, then I'm not totally sure what the answer is... I think maybe you would need to use U but I can't figure it out. "},{"studentID":"FedMWmwEd7W3C68gTqm66aRiqns2","answer":"F(x1 -> x2)","explanation":"F describes eventually, and the statement I wrote shows that if x1 is true then x2 is true thereafter"},{"studentID":"UJYax3ztBqcD2acHhEY8qP4lBhG3","answer":"F(x1 and F(x2))","explanation":"I'm assuming x2 can be true in the same state as x1"},{"studentID":"fRdxvbOnDTSVL5Ps9hTMqWSV5gc2","answer":"F(x1 -> X(G(x2)))","explanation":"G(x2) means always x2 is true. X(G(!x2)) means that in the next state, x2 is true from then on. x1 -> means that x1 being true implies this. F() means that this happens eventually."},{"studentID":"38eURZI12HU021gOG5x0zj61GYt1","answer":null,"explanation":null},{"studentID":"3C5iQZrpLIPHa4l0KSVRUYUAeYn2","answer":"F(~x1 v x2)","explanation":"(~x1 v x2) is logically equivalent to implies since if x1 evaluates to True, then x2 can be whatever and the whole predicate would still be true. If x1 evaluates to False then x2 has to be True for the whole predicate to be true. \n\nI add F to the front to say that 'eventually, there exists time i such that '~x1 v x2' holds' "},{"studentID":"VXpluGJOfOUe37IfyjNfFz3GymV2","answer":"F(x1 -> x2) ","explanation":""},{"studentID":"kExUsPs90Caj3ooAw3UTw6JiTYU2","answer":"F(x1 => X(x2))","explanation":""},{"studentID":"T4nr7nKQtkexYyVAi3NwCSqKC5n2","answer":"F(x1 -> G(X(x2))","explanation":"eventually (F) x1 being true implies that all future corresponding states has x2 being true"},{"studentID":"da61uKxwS4RS8uLw9e5aDhx9AAG2","answer":"F(x1 -> Gx2)","explanation":"if x1 is true, that implies that x2 is true in all subsequent states (G).  If this eventually holds, we can use F to represent that"},{"studentID":"ZdXWZhb3FQamAIjPsR8DFsmHhwe2","answer":"F(x1 -> F(x2))","explanation":"I believe \"thereafter\" can mean sometime in the future, so that is why I decided to wrap it in the eventually along with the rest of the statement."},{"studentID":"rsp3YalY4iYInzJzXy67djOCMdz2","answer":"F(x1=>x2)","explanation":"Eventually it is true that x1 implies x2"},{"studentID":"Urx7swvwyjUNbQ9lD233ds11JKJ3","answer":null,"explanation":null},{"studentID":"zKquIv2iqOPUbju84kD6x2oqxQC3","answer":"F(x1 => X(G(x2)))","explanation":"F = (eventually) if x1 is true x2 will be always true starting from the next state."},{"studentID":"g189tDKZqyfaI2GiXyXWcUWilJB2","answer":"F (x1 => X G x2)","explanation":"\"It eventually holds\" means our statement is wrapped in a \"eventually\" operator F. We need x1 to be true for the last part of the sentence to apply, so we have \"x1 =>\". The \"thereafter\" in \"x2 is true thereafter\" implies 1) that x2 is true for all states after the state in which x1 is true, and 2) that x2 is not necessarily true in the state where x1 is true. The former corresponds to the \"always\" operator G, while the latter adds a \"next\" operator X before the always."},{"studentID":"CUpKAZiiOrMlB7VEhcBrcxBDduN2","answer":"F(x1 -> X(x2))","explanation":"The following implication is eventually (F) true: x1 being true implies that the following (X) x2 is true"}]},{"prompt":"x2 is never true or x2 is true until x1 is true","rationale":"This problem requires students to negotiate multiple clauses","answers":[{"studentID":"06qfdQBcQyMQkXqkqBmyYkv99ns2","answer":"G(!x2) or x2 U x1","explanation":"G(!x2) means that x2 is never true.  x2 U x1 means that x2 is always true until some state in which x1 is true."}]},{"prompt":"x1 is always eventually true unless x2 is false and x3's next state is true","rationale":"I think this is interesting because it combined all the different versions of the states (always, eventually, next time) and relationships between x1 x2 and x3, and perhaps their complements.","answers":[{"studentID":"WAQ3dKACLtX8yKwCEVHHryA0JWz1","answer":"G(F(x1)) or (!x2 and X(x3))","explanation":"G(F(x1)) means x1 is always eventually true, the or means that is true unless the right side is true in which case unknown. The right side means x2 is fals and x3 is true in the next state"},{"studentID":"mkSbSzp0rUQ30XSeUq1F4HqG0S82","answer":"(!x2 && X(x3)) => !F(x1)","explanation":"I'm not sure if this really encodes what's described, but I also don't think what's described can be encoded. Right now what I have says if x2 is false and x3's next state is true, that implies that x1 doesn't end up finally true."},{"studentID":"Ao8FhZPEPeV6WdP0CYNeEiGGwP52","answer":"G( F(x1) ∨ (¬x2 ^ X(x3)))","explanation":"The outer G says that the inner expression always holds. The inner expression says either x1 is eventually true or x2 is not true and x3 is true in the next state. "},{"studentID":"TWeauYjl4mWo4O6eKbArWZz1s4s1","answer":"G(F(x1) U (!x2 and X(x3))","explanation":"G is always true, F is eventually true, and x U y means x is true until y is true"},{"studentID":"Olm3iZ1G75hC3g8kxg51POXFM402","answer":"!(!x2 & X(x3)) -> G(F(x1))","explanation":"if x2 is not true and x3 in the next state is true, the x1 will always be true eventually"},{"studentID":"rsp3YalY4iYInzJzXy67djOCMdz2","answer":"G(F(x1) U (!x2 and X(x3)))","explanation":"globally, eventually x1 unless not x2 and next state x3 is true"},{"studentID":"ehCdx7swHhPf72JGATgbRZ2e7rs1","answer":"F(x1)  - !x2 and x3","explanation":"Sorry I have no idea how to interpret unless and the next state of x3."},{"studentID":"FedMWmwEd7W3C68gTqm66aRiqns2","answer":null,"explanation":null},{"studentID":"SX5qjuY4LhdUlbePO48FvB797G53","answer":null,"explanation":null},{"studentID":"9FWl8IytHMMyyETmCpMUJijdoEj2","answer":"G( ~(!x2 and X(x3)) -> F(x1))","explanation":"if x2 is false and x3 is true in the next state then x1 will not eventually be true. So if the negation of the first condition holds then x1 will eventually be true."}]},{"prompt":"Amy, Barbara, and Catherine are friends who sometimes hang out in the lounge. However, there is an argument going on right now, such that some people will not hang out if certain others are there. Amy will not be present in the lounge if Catherine is there unless Barbara is also there to mediate. If Barbara and Amy are in the lounge together, Catherine will be hanging out with Barbara regardless of if they hang in the lounge of not. Eventually however, they will all hang out in the lounge together. Use x1, x2, and x3 to represent if Amy, Barbara, and Catherine are in the lounge respectively.","rationale":"Idk I just came up with some random idea.","answers":[{"studentID":"Z8I0Gua8DxZT3Lr3BGcIfZxlivI2","answer":"x3 -> ((!x1 and !x2) or (x1 and x2)) and (x1 and x2) -> x3 and F(x1 and x2 and x3)","explanation":"The first statement that \"Amy will not be present in the lounge if Catherine is there unless Barbara is also there to mediate\" means that Catherine implies not Amy and not Barbara, or both Amy and Barbara being present. The second statement  \"If Barbara and Amy are in the lounge together, Catherine will be hanging out with Barbara regardless of if they hang in the lounge of not\" is that both Amy and Barbara imply Catherine. And the last statement \"Eventually however, they will all hang out in the lounge together\" means that eventually all three will be in the lounge. "},{"studentID":"mkSbSzp0rUQ30XSeUq1F4HqG0S82","answer":null,"explanation":null},{"studentID":"Wy5fyfEMa6cPDN3JzFAmXgbXvaw2","answer":"G((x1 and x3) -> x2) and G((x2 and x1) -> x3) and F((x1 and x2) and x3)","explanation":""},{"studentID":"LKGb8fPfkfZIpgmptBwJeE7DlWm2","answer":"F(x1 and x2 and x3) and G(x3 and !x2 => !x1) and G(x2 and x1 => x3) ","explanation":"eventually they will all be true (in the lounge), all states  if x3 (catherine) is in the lounge and x2 (barb) is not then amy will not be in the lounge and in all states if x2 and x1 are in the lounge then x3 will be in the lounge"}]},{"prompt":"if x1 is true, x2 and x3 is false","rationale":"it's a basic question, everyone should know","answers":[{"studentID":"VcwHvUABF3hqOeJni9XH0HFRNwJ2","answer":"G(x1 => (not x2 and not x3))","explanation":"I used the G notation to encode that for all states in given traces, if x1 is true then x2 and x3 are not true."},{"studentID":"uq5XAODUszU4PMKhfbmC0y7kdlO2","answer":"x1 => (!x2 and !x3)","explanation":""},{"studentID":"ehCdx7swHhPf72JGATgbRZ2e7rs1","answer":"x1 -> (!x2 and !x3)","explanation":"-> means if."}]},{"prompt":"whenever x1 is true, x2 is true until x3 is true and x3 is true if x2 is true.","rationale":"I found this question to be interesting because atomic variables x2 and x3 are linked in a way that shuts down x2 (with until) when x3 is true.","answers":[{"studentID":"M513vZuSvAWfeOE0WZ7NWBieayn1","answer":"x1 -> ((x2 U x3) and (x2 -> x3))","explanation":"could also maybe just say, x1 -> (x2 and x3), because x2 will be true, and that will force x3 to be true, and that will alleviate the until requirement, allowing any state to occur again."},{"studentID":"Olm3iZ1G75hC3g8kxg51POXFM402","answer":"(x1 -> (x2 U x3)) & (x2 -> x3)","explanation":"x1 implies that before x3 is ture, x2 is true, and x2 is true implies x3 is true"},{"studentID":"kExUsPs90Caj3ooAw3UTw6JiTYU2","answer":null,"explanation":null}]},{"prompt":"It is always the case that when x1 and x2 are true, then sometimes x3 is true.","rationale":"I think this something that can't be shown through LTL because it's a branching possibility. LTL can't describe random events given a condition.","answers":[{"studentID":"OorJbOFV8odzg7bElwAX7qMXKeu2","answer":"G((x1 and x2) -> F(x3))","explanation":"I didn't really know how to write this. I said that always if x1 and x2 are true, then eventually x3 is true. But, I realize that this doesn't really make sense since eventually is not the same as sometimes."},{"studentID":"TWeauYjl4mWo4O6eKbArWZz1s4s1","answer":"G((x1 and x2) -> F(x3))","explanation":"G is always true and F is eventually (sometimes)"}]},{"prompt":"It is eventually true that x1 is always true when x2 and x3 false.","rationale":"This question is designed to illustrate the difference between \"it is eventually true that x1 is always true when x2 and x3 false\" and \"it is always true that x1 is eventually true when x2 and x3 false\"","answers":[{"studentID":"kd663bJTz0hO7SfexfzikeYZgj53","answer":"F (~x2 /\\ ~x3 => x1)","explanation":"finally, not x2 and x3 implies x1"},{"studentID":"3C5iQZrpLIPHa4l0KSVRUYUAeYn2","answer":"F(x2 v x3 v x1)","explanation":"The english statement can be translate literally into logic as \nF(~x2^~x3 ->x1)\nwe eliminate p -> q with ~p v q instead\nwe get\nF(~(~x2^~x3) v x1)\nwhich can be simplified to \nF((x2 v x3) v x1) <=> F(x2 v x3 v x1)"},{"studentID":"rx7fWLw9Uag06VhtzwrPHdWEKuC2","answer":"F(!x2 and !x3 -> G(x1))","explanation":"it eventually (F) holds, that x2/x3 being false implies that x1 is always (G) true"},{"studentID":"Urx7swvwyjUNbQ9lD233ds11JKJ3","answer":"F((~x2) ^ (~x3) -> G(x1))","explanation":"when x2 and x3 false implies x1 is always true"},{"studentID":"0HC3dpmLyKeoD74DguNF8DNwqrj1","answer":null,"explanation":null},{"studentID":"ehCdx7swHhPf72JGATgbRZ2e7rs1","answer":"(!x2 and !x3) -> F(G(x1))","explanation":"G means always and F means eventually. -> means when."},{"studentID":"p81246jCdnf8jPP6ckaxgaA9ceB3","answer":"F(x1 /\\ -x2 /\\ -x3)","explanation":"There is eventually a time step when the provided conjunction holds."},{"studentID":"VXpluGJOfOUe37IfyjNfFz3GymV2","answer":null,"explanation":null},{"studentID":"o4OspE6hSFUWj93icU8e3H220fm1","answer":"F((!x2 and !x3) => x1)","explanation":"Eventually, !x2 and !x3 implies x1 is true. I believe the \"always\" is explicit (and doesn't need a G) since F implies an always from state i and after."},{"studentID":"yavIxXSH3vfpUlXFgyEZ39leNop2","answer":"F(G(!(x2 and x3) => x1))","explanation":"F gives eventually, G gives always, and the implication shows the relation between x1 and (x2 and x3)"},{"studentID":"5IPmn9xCANgNuM7LIh9zG4wqqQc2","answer":"F(G((!x2 and !x3) -> x1))","explanation":"We need to start with the F operator since the sentence is \"eventually\" true. We know that x1 is always true when x2 and x3 are false, which means that x2 and x3 being false implies that x1 is true. We can write this is (!x2 and !x3) -> x1. We wrap this in a G to account for the fact that it's \"always\" true."}]},{"prompt":"If x1's next state is true, x2 will eventually be true","rationale":"It can check the basic state transitions of the LTL and rational logic.","answers":[{"studentID":"TWeauYjl4mWo4O6eKbArWZz1s4s1","answer":"X(x1) -> F(x2)","explanation":"X is the next state true and F is eventually true"},{"studentID":"M513vZuSvAWfeOE0WZ7NWBieayn1","answer":"X(x1) -> F(x2)","explanation":""},{"studentID":"5oLl7ZPijNYyMSwp55PwKSehzRq1","answer":"X(x1) /\\ F(x2)","explanation":"You must have both that the next state of x1 is true and that x2 is eventually true."}]},{"prompt":"if x1 is true two times in a row, it is never true again.","rationale":"I think this is interesting, because I found it tricky to conceptualize the idea of \"twice in a row\" until I saw some examples of it.","answers":[{"studentID":"da61uKxwS4RS8uLw9e5aDhx9AAG2","answer":"(x1 AND Xx1) ->G(NOT x1)","explanation":"Since X is the \"next state\" operator, both x1 and Xx1 have to be true.  Finally, we can use implication for the \"if\" part so that if both x1 and Xx1 are true, then in all subsequent states (G), x1 shouldn't be true."},{"studentID":"TWeauYjl4mWo4O6eKbArWZz1s4s1","answer":null,"explanation":null},{"studentID":"rkJV8Z8X1ENdbW3Sk2dTT0GsMmn1","answer":null,"explanation":null},{"studentID":"Mvw9fmUXFgVJjg6w1CCDcTkBdJo2","answer":"(x1 and X(x1)) -> X(X(G(!x1))","explanation":"x1 holding in this state and the next implies that from the next, next state onward, x1 is always false"},{"studentID":"06qfdQBcQyMQkXqkqBmyYkv99ns2","answer":"G((x1 and Xx1) => !F(x1))","explanation":"Applied globally, the condition (x1 and Xx1) (x1 is true in the current state and the next state, or twice in a row) implies !F(x1) (x1 will never be true again)."},{"studentID":"YZmWKZlgaZOrzGYNRp4TUVv5pZ13","answer":"(x1 and X(x1)) U (G(not(x1))","explanation":"The U/until operator expresses that the LHS is true first, and then the RHS. The LHS uses the X (next) operator to express two contiguous states of x1 being true. the RHS expresses the global/always state of x1 being NOT true. "},{"studentID":"R94tBoHz8ySNViJBvSke3qpd7N03","answer":"G((x1 and X(x1)) => X(X(G(!x1)))) ","explanation":"x1 and X(x1) is x1 being true twice in the row. This implies that 2 after (using X(X(...))) then x1 is always false (using G(!x1))"},{"studentID":"UJYax3ztBqcD2acHhEY8qP4lBhG3","answer":"G((x1 and X(x1)) -> X(X(G(!x1))))","explanation":"Globablly, if x1 is true in the current state and the next state, globablly from the next next state it is false"},{"studentID":"2uAPcLiTl6S6lkVxb49jwVczlXD2","answer":"F((x1 ∧ N(x1))∧G(N(N(¬x1))))","explanation":"Eventually x1 will be true two times in a row, and in the following states x1 will be false"},{"studentID":"uhSgQJpSx7dbcXRJqnQpLJPHK8s1","answer":"(x1:=true ^ ◯ x1:= true) -> G( x1:= false)","explanation":"I used implies because it's an if-then statement and G() to show that x1 will always be false"},{"studentID":"0HC3dpmLyKeoD74DguNF8DNwqrj1","answer":"x1 U x1 => F(!x1)","explanation":"According to the 8th rule under \"2 Semantics\" U accounts for the ith and the jth entry for the sequences where j = i+1 (so it represents \"two times in a row\") and x1 is true for both of these times. Then, I made it so that this implies that eventually x1 will not be true if x1 U x1"},{"studentID":"ZdXWZhb3FQamAIjPsR8DFsmHhwe2","answer":"(XXx1) -> G(-x1)","explanation":"I am still uncertain about the \"two times in a row\" concept but i believe the last part of always not x would satisfy the second part of the statement"},{"studentID":"o4OspE6hSFUWj93icU8e3H220fm1","answer":"G((x1 and X(x1)) => X(X(!x2)))U(!x2))","explanation":"I'm not totally sure about how to extract the i state where x1 is true two times in a row, and say x1 is false after state i. I tried using U, which has some sense of this progression, where x1 and X(x1) will be true, but then for all states after x1 will be false, but I don't think it actually works..."},{"studentID":"yqAbP1hwmpWXnQQRHWGW0uOlRPB3","answer":null,"explanation":null},{"studentID":"Olm3iZ1G75hC3g8kxg51POXFM402","answer":"(x1 & X(x1)) -> !X^2(x1)","explanation":"If x1 and x1's next state are true, then the follower states must be false"},{"studentID":"YzyRkeE37AhpGTSNU8zVMBwEojl1","answer":"x1 U x1 -> G(!x1)","explanation":"I think that the U function accounts for twice in a row, and then g function with not ensures it never happens again"},{"studentID":"phrbqZWVjcRh1ZJhWZHdh1yEhMZ2","answer":"(x1 and X(x1)) => G(X(X(!x1))","explanation":"x1 and X(x1) : means that x1 is true two times in a row\nG(X(X(!x1)) : means that in all states starting from the two in a row, x1 will be false"}]},{"prompt":"If it's always sunny outside (x1), then the plants will always eventually grow (x2) and you will also eventually get a sunburn (x3).","rationale":"I think it's fun to apply these properties to word problems and real-life scenarios! It's interesting to model things like this in different ways, and to see what kinds of situations this kind of logic is easily applicable to.","answers":[{"studentID":"qMF6ehxbIhSGK4673vpXIDWqRk92","answer":"G(x1)=>F(x2) and F(x3)","explanation":"Using G and F to express always and eventually"},{"studentID":"AxWttnGXbFOGMdMAoOcSQHoPFuB2","answer":"G(x1) => F(x2)and F(x3)","explanation":"The G captures the \"always\", but I wasn't sure if I had to wrap the whole thing in an always statement, as in for any subtrace."}]},{"prompt":"x1 is true in exactly one state. ","rationale":"I think it corresponds to G(x1 -> G(X(!x1))). If that's correct, then it is interesting because the implies achieves the 'exactly one' in the prompt.","answers":[{"studentID":"fRdxvbOnDTSVL5Ps9hTMqWSV5gc2","answer":"G(x1 -> X(G(!x1)))","explanation":"In all cases, once x1 becomes true, it means in the next case is x1 is false, and x1 will be false forever at that point."},{"studentID":"0YnVb35gVyZjh40kz442E1Z1mli1","answer":"x1 & !Xx1","explanation":"x1 only true once"},{"studentID":"eaIqaTs5sLTe88iSf2SdfYFDqPs2","answer":"This cannot be encode in LTL","explanation":""},{"studentID":"uhSgQJpSx7dbcXRJqnQpLJPHK8s1","answer":"x1:=true -> A^1","explanation":"Not sure how to account for the exactly one state so I just used A (from an online resources). "},{"studentID":"T4nr7nKQtkexYyVAi3NwCSqKC5n2","answer":"G(x1 -> G(X(!x1)))","explanation":"it's always true that if x1 is true, then the next state can never be true again"},{"studentID":"lRaLOybCkkdkd88UUN9jWGgL9fB3","answer":"F(x1) and G(x1 -> ~X(F(x1)))","explanation":"It must be true that x1 holds at some point (F(x1)) and that after it holds it doesn't anymore. This second part is achieved by requiring that no state in the future satisfies x1."},{"studentID":"j2h7kE6TUTe8mOHJ8n2gWkGvi922","answer":"I am not sure","explanation":"I am not sure how to count how many times a variable is true in a trace"},{"studentID":"CUpKAZiiOrMlB7VEhcBrcxBDduN2","answer":"G(x1 -> X(!x1) ^ (!x1 U x1))","explanation":"Always, x1 being true implies that the next (X) state is false, and, x1 is false up until x1 is true in this state."},{"studentID":"XXDQ67q4UiSR2kFxVzhaxL1hRZC3","answer":"F(¬x1Ux1) ∧ G(F(x1)U¬x1)","explanation":""},{"studentID":"u5LtkhMrVVVNvSHlNyzDQIjuWQl2","answer":"x1 and G(X(!x1))","explanation":"x1 holds at some state and x1 is false along the entire subsequence path starting at the next state"},{"studentID":"FJ1gcCB1SMXfbX4ehcXzcYHcs7l1","answer":"F(x1) ^ G(x1 => X(G(~x1)))","explanation":"F(x1) enforces that x1 is true in at least one state. We further want it so that, in that state, no state thereafter makes x1 true, so we want it that, in any state where x1 is true, all following state have ~x1. So, X(G(~x1)) enforces that all future states have ~x1, and x1 => X(G(~x1)) says for this to happen when x1 is true. Wrapping it in G makes it a global condition, which will then only be enforced in the one state where x1 is true. If x1 were true in two states, then the right condition would not hold in that first state."},{"studentID":"UJYax3ztBqcD2acHhEY8qP4lBhG3","answer":"F(x1 and X(G(!x1)))","explanation":"Once x1 is true, for all the states after, x1 is false"},{"studentID":"FK5jY3NfsvSIHK38KFpV6g8dFak1","answer":"Fx1 ^ (x1--> XG~x1)","explanation":"firstly Fx1 means x1 have to be true at some point (x1--> XG~x1) means that when x1 is true, the state after that cannot have x1 as true"},{"studentID":"R94tBoHz8ySNViJBvSke3qpd7N03","answer":"F(x1) and G(x1=>!F(x1))","explanation":"F(x1) is that it is true in some state. G(x1=>!F(x1)) is that after any state in which it is true, it is never true again. This implies that x1 is true exactly once."},{"studentID":"qMF6ehxbIhSGK4673vpXIDWqRk92","answer":"F(x1)","explanation":"x1 is eventually true"},{"studentID":"yLK6W8nyVrMUkNMyxFYLNsJdaPt2","answer":"x1->G(X(!x1))","explanation":"I really couldn't find anything in the notes on how to write \"exactly one state\" so basically my logic behind this statement is that when x1 is true then it always has to hold that the next state has to be false, which might mean that it holds in exactly one but like I said I wasn't really sure. "},{"studentID":"06qfdQBcQyMQkXqkqBmyYkv99ns2","answer":"!x1 U x1 and (x1 => !F(x1))","explanation":"!x1 U x1 means that x1 must hold in some state, and that x1 is false in all prior states.  x1 => !F(x1) means that in the state x1 holds, it is not the case that x1 will eventually hold again.  So, x1 is true exactly once, and never before or after that state."},{"studentID":"AAzmbLYzxbcuw8WEJsNweNOfr542","answer":"F(x1 AND G(NOT Xx1))","explanation":"It is eventually true that x1 and that always true that x1 is false in the next iteration thereafter"},{"studentID":"oHfP2KoEE8PHFh9JpFBlrT9FonJ2","answer":"G(x1!) U x1 -> G(!x1)","explanation":"x1 is always false until it is true which then implies that its always false again"},{"studentID":"WLnzJgg9usPE4u8WLnHafylGsSq1","answer":"G(~x1) U (x1 /\\ X(G(~x1)))","explanation":"x1 is never true until x1 becomes true and in the next state, x1 is never true."},{"studentID":"qsvPOzEQ1NeTrWs1iQmcqVOTHOJ3","answer":"G(F(x1 and G(X(!x1))))","explanation":"there exists an a sequence where x1 is true and the all the following states are all false, holds for all subsequences."},{"studentID":"kExUsPs90Caj3ooAw3UTw6JiTYU2","answer":"(x1 => X(G(!x1))) and (!x1 => F(x1))","explanation":"So I'm having some trouble here again conceptualizing how recursive/retroactive LTL is. What I'm trying to say above is that if x1 is currently true, then it will never be true again, and if it's false, then it will eventually be true. I think this should cover things, but wanted to acknowledge I'm not 100% sure in case that's helpful."},{"studentID":"YZmWKZlgaZOrzGYNRp4TUVv5pZ13","answer":"G(not(x1)) U x1 and X(not(x1)) U G(not(x1))","explanation":"In order to express the idea of \"exactly one state\" I started with the global (always) statement that x1 is not true, until x1 is true, but then in the immediately subsequent state (X operator), not x1 is true again, until x1 is again always not true. I'm not sure whether these last two expressions are redundant, but it seemed important to use the next operator to incorporate the idea of x1 being true for only one state."},{"studentID":"XsaC3AijqlTPGgknfTWr9Czhwed2","answer":"U(-x1) I(x1) (-x1)^(omega)","explanation":"x1 is true at an arbitrary i-th entry in the sequence I(x1). Up until that i-th entry, -x1 is true \"U(-x1)\" and after the i-th entry -x1 is always true \"(-x1)^(omega)\""}]},{"prompt":"if x1 is never true, then x2 and x3 will always alternate which is true, with only one being true at a time.","rationale":"I think the answer would be: G(!x1) implies ((x2 => X(!x2 and x3)) and (x3 => X(!x3 and x2))). I think it's interesting to decipher so many nested implies statements, as well as think about having to constrain both the case where x2 is true and x3 is true. ","answers":[{"studentID":"ehCdx7swHhPf72JGATgbRZ2e7rs1","answer":"G(!x1) -> G(x2 ∨ x3 and x2 ^ x3)","explanation":"G means always and x2 ∨ x3 and x2 ^ x3 means at a time only one, either x2 or x3 can be true."},{"studentID":"79DF8m2XmUOKjV8Ob9evefRWNHw1","answer":"G(!x1) -> G(x2 or x3) and !G(x2 and x3) and G(x2 -> X(!x2) and x3->X(!x3))","explanation":"There are three constraints. \n1: If x1 is never true, then it always holds that x2 or x3 is true\n2: x2 and x3 cannot be both globally true \n3: If x2 is true in a state, it is false in the subsequent one. Same for x3"},{"studentID":"06qfdQBcQyMQkXqkqBmyYkv99ns2","answer":"G(!x1) => G((x2 or x3) and (x2 => (!x3 and Xx3)) and (x3 => (!x2 and Xx2)))\n","explanation":"G(!x1) refers to the condition that x1 is never true.  This implies that globally, (x2 or x3) (x2 or x3 must always be true), x2 => (!x3 and Xx3) (if x2 is true then x3 is false in the current state and true in the next state), and x3 => (!x2 and Xx2) ) (if x3 is true then x2 is false in the current state and true in the next state).  So, if x1 is never true, then only exactly one of x2 or x3 will always be true and they will alternate which this is."},{"studentID":"DqLJt0Zj9WSlYXNbRSWqy1aCnyf2","answer":"G(!x1) => G((x2 and !x3) => X(!x2 and x3) and (!x2 and x3) => X(x2 and !x3))","explanation":"Since we only want to enforce alternating x3 and x2 if x1 is never true, we use a conditional with \"G(!x1)\", which chooses all traces where all traces set x1 to be false. Then, we want it to always hold that if a state sets x2 true and x3 false, then the next states sets x2 false and x3 true (alternating x2 and x3 true), and vice versa, so we wrap that set of conditionals with the global formula \"G\"."},{"studentID":"Ao8FhZPEPeV6WdP0CYNeEiGGwP52","answer":"F(x1) ∨ G( ¬(x2 ^ X(x2)) ^ ¬(¬x2 ^ X(¬x2)) ^ ¬(x3 ^ X(x3)) ^ ¬(¬x3 ^ X(¬x3)) ^ ¬(x2  ^ x3) )","explanation":"This says either x1 is at some point true, or the second expression is true. The second expression says that it is between every state and it's next state x2 switches values (the first two clauses), x3 switches values (the third and fourth clauses) and that x2 and x3 are different (the final clause)"}]},{"prompt":"x1 is true only when x3 is false, until the reverse is true eventually.","rationale":"I wanted the until to emulate the U, also including the idea of the implication and the !. ","answers":[{"studentID":"EbUb3Z6acpajSNs7t62nSh5UpGi2","answer":"((!x3 <=> x1) OR (!x3 <=> !x1)) AND (F(!x3 <=> !x1))","explanation":"We need to state that the the first predicate and its reverse both are allowed and valid, and we have to ensure that the reverse happens at some point (which is what the F after the AND does for us)."},{"studentID":"OorJbOFV8odzg7bElwAX7qMXKeu2","answer":"G((x1 iff (not x3)) iff (not E(x3 iff (not x1))))","explanation":"I tried to say that always, x1 is true iff x3 is false, iff we haven't eventually gotten a state where x3 is true iff x1 is false."}]},{"prompt":"If x1 is always true, then x2 will always be true until x3 is false","rationale":"I think that the notion of U and implications is interesting to figure out logically; these concept are pretty tricky to me, so translating from English to LTL and vice versa is pretty helpful!","answers":[{"studentID":"VXpluGJOfOUe37IfyjNfFz3GymV2","answer":"Gx1 -> G(x2 U!x3)","explanation":""},{"studentID":"obb14y1buwOu9DPHwVn15COD5Ky1","answer":"G(x1) => (x2 U ~x3)","explanation":"(x2 U ~x3) = x2 is true until x3 is false\nG(x1) => (x2 U ~x3)  = x1 is always true implies x2 until x3 is false"},{"studentID":"7YpZ1Wx49VhhkqMHvH1TZC9HKEz1","answer":"(not G x1) v (x2 U not x3)","explanation":"If x1 is not globally true, then x2 must be true until x3 becomes false to satisfy the statement. The main disjunction with the \"not\" in the first half functions as an implication."},{"studentID":"DqLJt0Zj9WSlYXNbRSWqy1aCnyf2","answer":"G(x1) => (x2 U !x3)","explanation":"- \"If x1 is always true\" -> \"G(x1) =>\"\n- \"x2 will always be true until x3 is false\" -> \"x2 U !x3\""}]},{"prompt":"whenever x1 is true, it becomes false in the next state and true again in the state after that","rationale":"This is a question that Tim thought would be interesting.","answers":[{"studentID":"SX5qjuY4LhdUlbePO48FvB797G53","answer":"G(x1 => (- X(x1) and X(X(x1)))","explanation":"At any trace step i, if x1 is true at state i then it will be false in state i+1 and true in state i+2."},{"studentID":"qsvPOzEQ1NeTrWs1iQmcqVOTHOJ3","answer":"G(x1 => (X(!x1) and X(X(x1)))","explanation":"these three conditions ensure that if x1 becomes true, then the next state must be false X(!x1) and the two states after the original one X(X(x1)) must evaluate to true."},{"studentID":"FJ1gcCB1SMXfbX4ehcXzcYHcs7l1","answer":"G(x1 => (X(~x1) ^ X(X(x1))))","explanation":"This is a condition that we want to always hold (G). It is a condition on x1 being true (hence \"x1 =>\"), and in those cases, we want ~x1 in the next state and x1 in the next next state (hence \"X(~x1) ^ X(X(x1))\").\n\nInterestingly, this means that as soon as x1 becomes true, it alternates true false true false ... on forever."},{"studentID":"FK5jY3NfsvSIHK38KFpV6g8dFak1","answer":"x1 <--> X~x1","explanation":"We want the alternate true false state, meaning that the state at time t+1 must be the negation of the state at time t\nx1 <--> X~x1 encode this info by saying that if x1 is true at time i ~x1 must be true at i+1 and vice versa"},{"studentID":"eaIqaTs5sLTe88iSf2SdfYFDqPs2","answer":"G(x1 -> (X(!x1) and X(X(x1))))","explanation":""},{"studentID":"Mvw9fmUXFgVJjg6w1CCDcTkBdJo2","answer":"x1 -> X(!x1) -> X(X(x1))","explanation":"X(X(x1) means the next, next state, so x1 is true in this state, false in the next - X(!x1) - and true in the next next state"},{"studentID":"VXpluGJOfOUe37IfyjNfFz3GymV2","answer":"(x1 -> X!x1) AND (x1 -> XXx1)","explanation":""},{"studentID":"u5LtkhMrVVVNvSHlNyzDQIjuWQl2","answer":null,"explanation":null},{"studentID":"g189tDKZqyfaI2GiXyXWcUWilJB2","answer":"G (x1 => (X ~x1) && (X X x1))","explanation":"We require that for all states, if x1 is true, we have both that ~x1 holds in the next state, and that x1 holds in the state after that. "},{"studentID":"lRaLOybCkkdkd88UUN9jWGgL9fB3","answer":"G(x1 -> (X(!x1) and X(X(x1))))","explanation":"Whenever implies G, and I use X to get at the next state and next next states"},{"studentID":"TWeauYjl4mWo4O6eKbArWZz1s4s1","answer":"x1 -> (X(!x1) and XX(x1))","explanation":"X is true in the next state, and XX is in 2 states"},{"studentID":"zKquIv2iqOPUbju84kD6x2oqxQC3","answer":"G(x1 => (X(!x1) and X(X(x1))) )","explanation":"It always holds that if x1 is true, x1 is false in the next state and x1 is true in the state after that."},{"studentID":"FRxTfpBnCXSBY762KVw7F5DTJ0r1","answer":"G(x1 -> X(!x1) and X(X(x1)))","explanation":"It is always the case that if x1 is true implies that x1 is false in the next state and is true in the next next state"},{"studentID":"CUpKAZiiOrMlB7VEhcBrcxBDduN2","answer":"x1 -> X(x1)^X(X(x1))","explanation":"This is just an implication, so when x1 is true, the next state (X(x1)) is true, and the next next state (X(X(x1))) is also true"},{"studentID":"oHfP2KoEE8PHFh9JpFBlrT9FonJ2","answer":null,"explanation":null},{"studentID":"n6X9W01WPlSOMef0b3WU2WBmqVC2","answer":"G(x1 -> (X(¬x1) ^ X(X(x1))))","explanation":"\"whenever\" := G"},{"studentID":"da61uKxwS4RS8uLw9e5aDhx9AAG2","answer":"x1 -> X NOT x1 -> XX x1","explanation":"If x1 is true in a given state, that implies that the next state should include NOT x1, which in turn implies that the next next state (XX) should be true again"},{"studentID":"SXuWPt2DVGRMnfN2ELdVux2pv9j2","answer":"G(x1 => X(!x1) and X(X(x1)))","explanation":"whenever x1 is true = G(x1 => ...), false in the next state = X(!x1), true again in the state after that = X(X(x1))"},{"studentID":"T4nr7nKQtkexYyVAi3NwCSqKC5n2","answer":"(x1 => X(not x1))  ^ (not x1 => X(x1))","explanation":"If x1 is true, the next state is false, and then it's true, but then the cycle keeps going, so x1 flipflops between being true and false every state transition. So, if x1 is currently true, it should be false next, and if it's not true, it should be true next."},{"studentID":"AAzmbLYzxbcuw8WEJsNweNOfr542","answer":"G(x1 implies (Xx1 AND XXx1))","explanation":"It is globally true that x1 implies x1 in the next and the next next state."},{"studentID":"9FWl8IytHMMyyETmCpMUJijdoEj2","answer":"x1 -> X(!x1) and X(X(x1))","explanation":"if x1 is true then in the next state it will be false and the next next state it will be true."},{"studentID":"XsaC3AijqlTPGgknfTWr9Czhwed2","answer":null,"explanation":null},{"studentID":"OorJbOFV8odzg7bElwAX7qMXKeu2","answer":"x1, X( not x1, X(x1))","explanation":"I used nested operators"},{"studentID":"fRdxvbOnDTSVL5Ps9hTMqWSV5gc2","answer":"x1 -> X(!x1) and !x1 -> X(x1)","explanation":"x1 -> X(!x1) means that if x1 is true, it is false in next state. !x1 -> X(x1) means that if x1 is false, it is true in next state."},{"studentID":"k6kvJj5VCUPWLj2ppeOMNVBQzeJ2","answer":"G(x1 -> (X(!x1) and X(X(x1))))","explanation":"I am using G to say this always holds. I am using X in order to refer to the next state and two X's to get two states ahead."},{"studentID":"yLK6W8nyVrMUkNMyxFYLNsJdaPt2","answer":null,"explanation":null},{"studentID":"XKjYJO7zc0dP1NfMtzP4jbagTLR2","answer":"G(x1 => X(!x1) and X(X(x1))","explanation":"\"Whenever\" means that the property always holds, so G is needed"},{"studentID":"UJYax3ztBqcD2acHhEY8qP4lBhG3","answer":"G(x1 U X(!x1 and X(x1)))","explanation":"Enforces that globally, if x1 then one state later !x1 and two states later x1"},{"studentID":"LAeoyaF0twbF0V1g5eQ2GEPsxJE2","answer":"G(~x1 \\/ (~X(x1) /\\ X(X(x1))))","explanation":"Pretty straightforward."},{"studentID":"uhSgQJpSx7dbcXRJqnQpLJPHK8s1","answer":"x1:= true -> ◯ x1:= false ^ ◯ x1:= true","explanation":"I used implies because its an if-then statement and ◯ means next state (from online resource) "}]},{"prompt":"If x1 is true in the next step then x1 will always eventually be true.","rationale":"This statement tests the understanding of X (in the next step), G (always), and F (eventually). In addition, is it interesting to see how \"then\" is written, whether it is via -> or otherwise.","answers":[{"studentID":"M513vZuSvAWfeOE0WZ7NWBieayn1","answer":null,"explanation":null},{"studentID":"EbUb3Z6acpajSNs7t62nSh5UpGi2","answer":"X(x1) => F(x1)","explanation":"Using X to represent next step and F to represent eventually."},{"studentID":"yqAbP1hwmpWXnQQRHWGW0uOlRPB3","answer":null,"explanation":null},{"studentID":"5oLl7ZPijNYyMSwp55PwKSehzRq1","answer":"X(x1) /\\ G(F(x1))","explanation":"Traces must have both that the next step is true and that x1 is always eventually true."},{"studentID":"p81246jCdnf8jPP6ckaxgaA9ceB3","answer":"X(x1) => X(x1)*","explanation":"Implying that if x1 holds in the next time, then x1 will hold in all following time steps."},{"studentID":"Wy5fyfEMa6cPDN3JzFAmXgbXvaw2","answer":"X(x1) -> F(x1)","explanation":"Supposing that X(x1) means that x1 is true in the next step, and not x1 is true *starting* next step, then it will eventually be true. If X(x1) means that x1 is true *starting* next step, then the rest is redundant."},{"studentID":"Ao8FhZPEPeV6WdP0CYNeEiGGwP52","answer":"¬ (X(x1) ^ ¬G(F((x1)))","explanation":"This expression says that it is not the case that x1 is true in the next step, but not always eventually true. G does the always, and F does the eventually. "},{"studentID":"rsp3YalY4iYInzJzXy67djOCMdz2","answer":"X(x1) => F(x1)","explanation":"if x1 is true in the next state, then eventually x1 will hold as true"},{"studentID":"1PfpKQ5FbSaFVpjLU0zEvi2Vsni2","answer":"X(x1) and G(F(x1))","explanation":"In words X(x1) means in the next step x1 is true. G(F(x1)) means x1 is always eventually true. Together they mean that if x1 is true in the next step then x1 will always eventually be true. I'm not sure if I correctly codified the \"if\" because I think this might be saying it is the case that x1 is true in the next step and x1 will always eventually be true, rather than \"if\" this is the case..."}]},{"prompt":"The truth value of x1 alternates at each state.","rationale":"I think this could be interesting because it requires you to think about all states but also the next state in relation to the truth value of x1 in the current state.","answers":[{"studentID":"kExUsPs90Caj3ooAw3UTw6JiTYU2","answer":"G( (x1 => X(!x1)) and (!x1 => X(x1)))","explanation":"I'm pretty sure this is the one I submitted! Hopefully it's correct :)"},{"studentID":"UKl2qkKWlKO6BQ9PwxsbdegpkDV2","answer":"w ⊨ G((x1 ⟹ X(¬x1)) ∧ (¬x1 ⟹ X(x1)))","explanation":"In all states, we want x1 to mean that in the next state x1 is false and ¬x1 to mean that in the next state x1 is true. So, we use G to say that this condition must always hold. To use the next state, we use X, so we have (x1 ⟹ X(¬x1)) ∧ (¬x1 ⟹ X(x1)), meaning overall w ⊨ G((x1 ⟹ X(¬x1)) ∧ (¬x1 ⟹ X(x1)))."}]},{"prompt":"x1 starts out True. Once it is False, it is false in every state after. ","rationale":"We have an operator that describes all states until an event happens, but we don't have one that describes all the states after an event happens. ","answers":[]},{"prompt":"Jack got 50 in his midterm exam but he didn't want to fail that course and Jack had 100 in his final.","rationale":"Just curious how to interpret what I just wrote into LTL. ","answers":[{"studentID":"EbUb3Z6acpajSNs7t62nSh5UpGi2","answer":"x1 and x2 and x3","explanation":"x1 is equal to jack getting a 50 on his midterm, x2 is equal to jack not wanting to fail, x3 is equal to jack getting a 100 on his final."}]},{"prompt":"x1 and x2 will eventually become true at the same time.","rationale":"F(x1 and x2) means that eventually both x1 and x2 will be true, but does not guarantee that one will bot become true before the other. I am looking for:\n\" F(x1 and x2) and G((!x1) -> (!x2)) and G((!x1) -> (!x2)) \" or something similar, to signify that x1 and x2 must have the same value.","answers":[{"studentID":"06qfdQBcQyMQkXqkqBmyYkv99ns2","answer":"F(x1 and x2)","explanation":"(x1 and x2) means that x1 and x2 are true in the same state.  F(x1 and x2) means that this will eventually hold."}]},{"prompt":"It's always true that if x1 is true that in the previous state x1 is false, and that x1 was true 2 states ago","rationale":"There is no way to backtrace to a previous state, so must use X instead\n","answers":[{"studentID":"FedMWmwEd7W3C68gTqm66aRiqns2","answer":"x2 -> G(X(!x1) -> X(X(x1)))","explanation":"If x2 is true, then it will always hold that the next state of x1 is false implies that the next next state of x1 is true"},{"studentID":"VcwHvUABF3hqOeJni9XH0HFRNwJ2","answer":"G( x1 => X(!x1) and XX(x1))","explanation":"I'm really uncertain about this what I think I'm conveying is that for all states if x1 is true then a transition later it will be false and two transitions later it will be true again using the X(!x1) and XX(x1) notations. This sets it up such that if x1 is true then it was false in the previous state and true two states ago."},{"studentID":"9FWl8IytHMMyyETmCpMUJijdoEj2","answer":"G( (X(x1) -> !x1) and 2StatesAgo(x1) ","explanation":"It's globally true that is x1 is true in the next state, then it is false in the current (if there's a previous equivalent to X() then I would've used that) and IDK how to say 2 state ago."},{"studentID":"uq5XAODUszU4PMKhfbmC0y7kdlO2","answer":"G(XX(x1) => (X(!x1) and XX(x1))","explanation":"This is a little funky, because we're dealing with the \"past\" by going into the future, but the more I think about it the more it makes sense."},{"studentID":"o4OspE6hSFUWj93icU8e3H220fm1","answer":"G(x1 and X(!x1) and X(X(x1)))","explanation":"I think this represents just x1 flipping from true to false each turn, but my formula represents the spirit of the wording, marking \"2 states ago\" as plain x1, and then using X(X(x1)) to represent the \"present\" state."},{"studentID":"WLnzJgg9usPE4u8WLnHafylGsSq1","answer":"G((x1 /\\ ~Xx1 /\\ XXx1) \\/ (~x1 /\\ Xx1 /\\ ~XXx1)) \\/ G(~x1)","explanation":"It's always the case that x1 is true and x1 is true two states from now, and the intermediate state is false, or vice versa, or x1 is never true."},{"studentID":"rsp3YalY4iYInzJzXy67djOCMdz2","answer":"G(x1 <=> (X(!x1) and X(X(x1))))","explanation":"Always true that x1 is true if and only if  the next state has !x1 and that the next, next state has x1"}]},{"prompt":"If x1 holds true, until x2 holds true twice, it cannot hold true again.","rationale":"I think it's interesting because you have to consider x1 being true one time without any constraints, and then following events where there is a constraint involving x2 that must be satisfied if x1 is to be true again.","answers":[]},{"prompt":"Either for every 5th time step x1 and x2 is true or for every 3rd time step x3 is true.","rationale":"This is interesting for me because for each trace defined one would have to model that either for every 5th time step some property holds or for every 3rd time step some different property holds.  It would be interesting to see how X would be used with G because a proposition has to be globally true for EVERY ith time step rather than just for every time step.","answers":[{"studentID":"AxWttnGXbFOGMdMAoOcSQHoPFuB2","answer":"G(X(X(X(X(X(x2)))) or X(X(X(x3))))","explanation":"This would imply that for every subdivided sequence, although I don't think it gets at exactly what the original statement is going for."},{"studentID":"Wy5fyfEMa6cPDN3JzFAmXgbXvaw2","answer":"G(XXXX(x1 and x2)) or G(XX(x3))","explanation":"Unsure if the desired formula can be expressed in LTL."},{"studentID":"EbUb3Z6acpajSNs7t62nSh5UpGi2","answer":"X(X(X(x3))) OR X(X(X(X(X(x1 AND x2)))))","explanation":"Each x represents a step; x3 is true in 3 steps OR x1 and x2 are true every 5 steps."},{"studentID":"5oLl7ZPijNYyMSwp55PwKSehzRq1","answer":"((x1/\\ x2) /\\ XXXXX(x1 /\\ x2)) \\/ (x3 /\\ XXX(x3))","explanation":"If at the current step x1 and x2 are true and if the step in 5 next's has x1 and x2 as true, then x1 and x2 are true at every fifth time step, the same applies for every third timestep."},{"studentID":"1PfpKQ5FbSaFVpjLU0zEvi2Vsni2","answer":"G(X(X(X(X(x1 or x2)))) or G(X(X(x3)))","explanation":"G(X(X(X(X(x1 or x2)))) means every 5th timestep has x1 or x2 true, and G(X(X(x3))) means every 3rd timestep x3 is true."},{"studentID":"2uAPcLiTl6S6lkVxb49jwVczlXD2","answer":"F(N(N(N(N(N(x1 ∧ x2)))))) ∨ F(N(N(N(x3))))","explanation":"Couldn't figure out how to explicitly define every nth time step, so created a loose description "},{"studentID":"phrbqZWVjcRh1ZJhWZHdh1yEhMZ2","answer":null,"explanation":null},{"studentID":"kExUsPs90Caj3ooAw3UTw6JiTYU2","answer":"(F(x1 and x2) and G(x1 and x2 => X(X(X(X(x1 and x2)))))) or ( F(x3) and G(x3 => X(X(x3))))","explanation":"This one I am particularly not confident about. I had trouble with the idea of \"for every xth time\" because I'm not sure how LTL could be used like that. I think the above says \"once ___ is true, then it will be true every xth time\", which I know is not exactly the same."},{"studentID":"uq5XAODUszU4PMKhfbmC0y7kdlO2","answer":"XXXXX(x1 and x2) or XXX(x3)","explanation":"There's probably a better way of doing this, as this doesn't really work if one thinks about \"stepping\" forward (I think)"}]},{"prompt":"At any point, exactly 2 of x1, x2, and x3 have the same truth value, and the variables that have the same truth value switch at each step.","rationale":"This statement is tricky to encode because we do not specify which variables have to be true and/or false at each step, and between steps, we cannot just swap the truth values of each variable. Additionally, it seems easy to overconstrain.","answers":[{"studentID":"Olm3iZ1G75hC3g8kxg51POXFM402","answer":"(x1 & x2 & !x3) | (x1 & !x2 & x3) | (!x1 & x2 & x3)","explanation":"Even though the value will switch, since they're exactly two value with true, their values are not changed"},{"studentID":"Ao8FhZPEPeV6WdP0CYNeEiGGwP52","answer":"G( (¬(x1 ^ x2 ^ x3) ^ ¬(¬x1 ^ ¬x2  ^ ¬x3)) ^ ¬(x1 ^ X(x1)) )","explanation":"The outer G says the inner statement should always be true. The first clause of the inner statement makes sure that all three variables aren't the same, which gaurentees that exactly two will be the same. The second clause makes sure that the value of x1 changes in the next step, stopping everything from staying the same. "},{"studentID":"OorJbOFV8odzg7bElwAX7qMXKeu2","answer":"I dont know","explanation":"The problem statement is not very clear. The second part of the statement says \"the variables that have the same truth value switch at each step\". It is unclear what switching means here. "},{"studentID":"rsp3YalY4iYInzJzXy67djOCMdz2","answer":"G(((x1 and x2 and !x3) or (x1 and !x2 and x3) or (!x1 and x2 and x3)) and ((x1 and x2 and !x3) => X(x1 and !x2 and x3) or X(!x1 and x2 and x3)) or ((x1 and !x2 and x3) => X(x1 and x2 and !x3) or X(!x1 and x2 and x3)) and ((!x1 and x2 and x3) => X(x1 and !x2 and x3) or X(x1 and x2 and !x3)))","explanation":"Always, either x1,x2,!x3 or x1,!x2,x3 or !x1,x2,x3 and each one of those implies the next state is one of the other ones."},{"studentID":"yavIxXSH3vfpUlXFgyEZ39leNop2","answer":"G(x1 and x2 => !X(x1) and !X(x2) and !x3 or x2 and x3 => !X(x2) and !X(x3) and !x1 and x1 or x3 => !X(x1) and !X(x3) and !x1)","explanation":"The phrase \"at any point\" means we need a global operator, the exactly 2 of 3 can be handled via 3 part implication, and the switching can be handled with the X operator. "},{"studentID":"79DF8m2XmUOKjV8Ob9evefRWNHw1","answer":"G( (x1 and x2 and !x3) or (x1 and x3 and !x2) or (x2 and x3 and  !x1) and \n(!x3 -> X(x3) and !x2 -> X(x2)  and !x1 -> X(x1)))","explanation":"Consists of two parts that always holds. First, I just enumerated all the possibilities for 2 variables out of 3 to be set to true. \nThe second part includes the constraint that if a variable is set to false in current state, it should be true in the subsequent. \n"},{"studentID":"DfrktEsV96QCmKYSnC1SkAZ92Jm1","answer":"G(((x1 <=> x2) and ~X(x1 <=> x2)) or ((x1 <=> x3) and ~X(x1 <=> x3))  or ((x3 <=> x2) and ~X(x3 <=> x2)))","explanation":"I don't think this is even correct but I don't see a concise way of representing this formula"}]},{"prompt":"x3 is true if and only if x1 and x2 are true in the previous state and x1 and x2 are eventually true. ","rationale":"This is like turning two keys (x1 and x2) to trigger an event (x3). ","answers":[{"studentID":"LKGb8fPfkfZIpgmptBwJeE7DlWm2","answer":"[x1 and x2 and F(X(x1)) and F(x2) => x3 ] and [!{x1 and x2 and F(X(x1)) and F(x2) } => !x3 ]","explanation":"for an iff you have to enforce both version of the implies, otherwise it was just a simple implies. \nUsed X to talk about next state so we could refer to x1 and x2 as the state previous to that, did a bunch of ands to enforce all the cases"},{"studentID":"Z8I0Gua8DxZT3Lr3BGcIfZxlivI2","answer":"(X(x3) -> (x1 and x2 ) ) and ((x1 and x2 )  ->X(x3) ) and F(x1 and x2)","explanation":"The statement is an IFF so it must be bidirectional, which is why I have the ANDing of two symmetric imply statements. Now the statements themselves just say that x1 being true and x2 being true implies in the next state x3 being true (and the reverse). Lastly,  x1 and x2 are eventually true is the last ANDed statement. "},{"studentID":"7YpZ1Wx49VhhkqMHvH1TZC9HKEz1","answer":"((Xx3 ^ (x1 ^ x2)) v (not Xx2 ^ not (x1 and x2))) ^ F(x1 ^ x2)","explanation":"I think that we can use \"X\" to say that x3 is true in the next state iff x1 and x2 are true in this state, which I think is the same as x1 and x2 being true in the previous state iff x3 is true in the current state. I think the second half of the statement is just a normal \"F\" clause."},{"studentID":"obb14y1buwOu9DPHwVn15COD5Ky1","answer":"(X(x3) <=> (x1 /\\ x2)) /\\ F(x1 /\\ x2)","explanation":"x1 /\\ x2 = x1 and x2 are both true in this state\nX(x3) = x3 is true in the next state.\nB iff (A = prev(B) is the same as saying A iff (B = next(A). \nThe second part seems ambiguous because its unclear whether it means that (x1 /\\ x2) is eventually true or whether (x1) and (x2) are eventually true independently. I'm assuming its asking that there is a state where (x1 /\\ x2) is eventually true, which is equal to F(x1 /\\ x2). "},{"studentID":"kExUsPs90Caj3ooAw3UTw6JiTYU2","answer":"G(X(x3) <=> (x1 and x2 and X(F(x1 and x2))))","explanation":"I treated this as everything after \"if and only if\" being grouped together, but the wording is ambiguous."},{"studentID":"06qfdQBcQyMQkXqkqBmyYkv99ns2","answer":"(F(x1) and F(x2) and (x1 and x2)) => Xx3","explanation":"If x1 is eventually true and x2 is eventually true and x1 and x2 are currently true, then x3 is true in the next state."},{"studentID":"mkSbSzp0rUQ30XSeUq1F4HqG0S82","answer":"(x1 && x2) <=> (X(x3)), F(x1), F(x2)","explanation":"x1 and x2 are only true if x3 is true in the next state, x1 and x2 are finally true."}]},{"prompt":"Anybody coming back from the park will have a buddy, and going to the park alone means that you will never come back. x1 and x2 represent person 1 and person 2 going to the park; x3 and x4 represent them, respectively, coming back.","rationale":"While this scenario seems like a finite set of events, with LTL, we can model this so that it never comes to an end. I found that \"pedantic\" point fun to think about, especially how it was \"infinities\" as such might exist.","answers":[]},{"prompt":"Whenever x1 is true, x1 is false and x2 is true in the state after; whenever x2 is true, x1 is false and x1 is true in the state after","rationale":"tests the relationship between two variables and successor states","answers":[{"studentID":"UKl2qkKWlKO6BQ9PwxsbdegpkDV2","answer":"w ⊨ G(x1 ⟹ X(¬x1 ∧ x2)) ∧ G(x2 ⟹ X(x1 ∧ ¬x2))","explanation":"If x1 is true, then in the next state it will be false and x2 will be true. We use X to get to the next state, so this is expressed as x1 ⟹ X(¬x1 ∧ x2). This should be true whenever x1 is true, so this implication must always be true, meaning we use G so we have G(x1 ⟹ X(¬x1 ∧ x2)). But then, this same expression should hold about x2, so we flip the variables and make both versions true, giving us w ⊨ G(x1 ⟹ X(¬x1 ∧ x2)) ∧ G(x2 ⟹ X(x1 ∧ ¬x2))."},{"studentID":"FedMWmwEd7W3C68gTqm66aRiqns2","answer":"G(x1 -> X(!x1 and x2) and G(x2 -> X(!x1 and x1)","explanation":"Whenever means that it always will hold that when x1 is true, x1 will be false and x2 will be true in the next state, and the same for when x2 is true"},{"studentID":"rsp3YalY4iYInzJzXy67djOCMdz2","answer":"(x1 => X(!x1 and x2)) and (x2 => (!x1 and X(x1)))","explanation":"x1 implies that the next state has !x1 and x2; x2 implies !x1 and the next state has x1"},{"studentID":"5IPmn9xCANgNuM7LIh9zG4wqqQc2","answer":"G(x1 => X(!x1 and x2)) and G(x2 => X(!x1 and x1))","explanation":"I think there's a typo in this, as the second half says \"whenever x2 is true, x1 is false and x1 is true in the state after\", which seems like a logical fallacy since x1 can't be both true and false in the same state, but I expressed it in the equation anyway. We start with x1 => X(!x1 and x2) because we know that x1 being true implies that in the next state, x1 is false and x2 is true. This is wrapped in a G because it always holds. The second half is very similar; x2 => X(!x1 and x1) because x2 being true implies that \"x1 is false and x1 is true\" in the next state, which also always holds."},{"studentID":"Z8I0Gua8DxZT3Lr3BGcIfZxlivI2","answer":"G(x1 -> X(!x1 and x2) and x2 -> X( !x1 and  x1 ))","explanation":"Since the term whenever is used (meaning always) everything is wrapped in a G. Both the internal statements use implies to show how the state of x1 and x2 imply something about the next state of x1 and x2."},{"studentID":"phrbqZWVjcRh1ZJhWZHdh1yEhMZ2","answer":"G(!x1 and !x2)","explanation":"x1 => (X(!x1 and x2)) : means that if x1 is true, x1 is false and x2 is true in the state after\nx2 => X(!x1 and x1) : means that if x2 is true, x1 is both true and false in the state after. \n\nHowever, this cannot happen so x2 cannot be true (it is a contradiction). Therefore, x1 must also be false because\nit being true implies that x2 is true in the state after. So x1 and x1 must always be false"},{"studentID":"yqAbP1hwmpWXnQQRHWGW0uOlRPB3","answer":"x1 => X(!x1 and x2), x2 => !x1 and X(x1)","explanation":"when x1 is true, that implies in the next state !x1 and x2.  when x2 is true, that implies !x1 and in the next state x1."},{"studentID":"rx7fWLw9Uag06VhtzwrPHdWEKuC2","answer":"(x1 -> X(!x1 and x2)) and (x2 -> !x1 and X(x1))","explanation":"the state after is denoted by X, and the two parts of the LTL expression are when x1 is true and when x2 is true"},{"studentID":"mkSbSzp0rUQ30XSeUq1F4HqG0S82","answer":"x1 => (X(!x1) && X(x2)), x2=> (!x1 && X(x1))","explanation":"This description is sort of goofy, but what I have above should be the only valid interpretation. "}]},{"prompt":"Every time x1 is true, eventually x2 is true or the next x3 is false","rationale":"I think this is somewhat interesting since it's somewhat counterintuitive to think about next states among different variables. Also, this is interesting because it mixes eventually, and implies (x1 -> F(x2 V X(!x3)))","answers":[{"studentID":"XXDQ67q4UiSR2kFxVzhaxL1hRZC3","answer":"G(x1=>F(x2) ∧ ¬X(x3))","explanation":"It requires for every x1, either \"eventually x2\" is true or \"the next x3\" is false"},{"studentID":"SXuWPt2DVGRMnfN2ELdVux2pv9j2","answer":"G(x1 => F(x2) or X(!x2))","explanation":"Every time x1 is true = G(x1 => ...), eventually = F, next = X"},{"studentID":"yavIxXSH3vfpUlXFgyEZ39leNop2","answer":"G(x1 => (F(x2) or !X(x3)))","explanation":"Globally accounts for \"every time\", F(x2) gives eventually x2 and X(x3) gives the next x3."},{"studentID":"Urx7swvwyjUNbQ9lD233ds11JKJ3","answer":"x1 -> F(x2) and X(x3)","explanation":"X can express \"next\""},{"studentID":"5IPmn9xCANgNuM7LIh9zG4wqqQc2","answer":"G(x1 -> (F(x2) or X(!x3)))","explanation":"\"Every time x1 is true\" means the formula has to start with a G and an x1. Eventually means F, so \"eventually x2 is true\" translates to F(x2). We can encode the next x3 being false using the X operator, i.e. X(!x3). Thus G(x1 -> (F(x2) or X(!x3)))."},{"studentID":"CUpKAZiiOrMlB7VEhcBrcxBDduN2","answer":"G(x1 -> (F(x2) or X(!x3)))","explanation":"Always, x1 implies eventually (F) x2 is true, or next (X) x3 is false"},{"studentID":"LAeoyaF0twbF0V1g5eQ2GEPsxJE2","answer":"G(~x1 \\/ (F(x2) \\/ X(x3)))","explanation":"We need to use all of G, F, and X."},{"studentID":"qsvPOzEQ1NeTrWs1iQmcqVOTHOJ3","answer":"G(x1=>(F(x2) or X(!x3)))","explanation":"G(x1=> implies that whenever x1 becomes true, (F(x2) or X(!x3)) implies that eventually x2  is true, or the next x3 is false."},{"studentID":"zKquIv2iqOPUbju84kD6x2oqxQC3","answer":"G(x1=>(F(x2) or X(!x3)))","explanation":"G = (always), so G(x1 => b) means that every time x1 is true b should happen. In this case, b is F(x2) or X(!x3): F = (eventually), so either b is eventually true or X = (next) the next x3 is false."},{"studentID":"R94tBoHz8ySNViJBvSke3qpd7N03","answer":"G(x1 => (F(x2) or X(x3))","explanation":"G is for every time, F is for eventually and X is next. Otherwise it follows directly."},{"studentID":"u5LtkhMrVVVNvSHlNyzDQIjuWQl2","answer":"x1 -> (F(x2) or X(!x3))","explanation":""},{"studentID":"kOYh8lB1WQhEgx5Pte67U4XSnE93","answer":"x1 implies F(x2) or X(!x3)","explanation":"My idea is to think of the instance when x1 is true, we have two options: F(x2), meaning that x2 is true, or that X(!x3), the next x3 is false. One thing that I'm a little bit unsure about is how the wording \"Every time\" affects the LTL statement. If x1 is true once, that will always be the case that the things after will follow, but I just assumed it wouldn't affect it? But I'm not completely sure."},{"studentID":"YzyRkeE37AhpGTSNU8zVMBwEojl1","answer":"x1 -> F(x2) OR X(x3)","explanation":"My answer is somewhat self-explanatory here : x1 beings true implies that x2 is eventually true (F function) or the next x3 is false (X function)"},{"studentID":"XsaC3AijqlTPGgknfTWr9Czhwed2","answer":"x1-> F(x2) OR X(-x3)","explanation":"x1 being true \"x1\" implies \"->\" x2 is eventually true \"F(x2) or \"OR (using this to represent the logical or operator)\" the next \"X( )\" x3 is false \"-x3\". I was a little unclear if \"the next x3 is false\" meant that the next part of the trace was a false x3, or eventually there was an x3 and that x3 was false, but I went with the first assumption. "},{"studentID":"qMF6ehxbIhSGK4673vpXIDWqRk92","answer":"x1 -> F(x2) or !x3","explanation":""},{"studentID":"1utNHrKBy7T4nb34YbOeaMGFzxl1","answer":"G(x1) => F(x2) U X(!x3)","explanation":"Every time can be translated to always x1 implies the last portion of the expression. "},{"studentID":"0HC3dpmLyKeoD74DguNF8DNwqrj1","answer":"x1 => (F(x2) OR XX(!x3))","explanation":"x1 implies that eventually (F) x2 is true, or the subsequent (XX) x3 is false"},{"studentID":"fRdxvbOnDTSVL5Ps9hTMqWSV5gc2","answer":"G( (x1 -> ( F(x2)) or X(!x3) ) )","explanation":"The G() means it is always true. x1 -> means that x1 being true implies something. F(x2) means eventually x2 is true. X(!x3)  means the next x3 is false."},{"studentID":"eaIqaTs5sLTe88iSf2SdfYFDqPs2","answer":"G(x1 => (F(x2) or X(!x3))","explanation":""},{"studentID":"da61uKxwS4RS8uLw9e5aDhx9AAG2","answer":"x1 -> (Fx2 OR (X NOT x3))","explanation":"whenever x1 is true, that implies that either (OR) x2 should be true at some point (F), or NOT x3 should be true in the next state (X)"},{"studentID":"rkJV8Z8X1ENdbW3Sk2dTT0GsMmn1","answer":"x1 -> ((F x2) ∨ (X ¬x3))","explanation":"x1 being true implies that, from that point on, x2 is eventually true or x3 is false in the next state."},{"studentID":"FJ1gcCB1SMXfbX4ehcXzcYHcs7l1","answer":"G(x1 => (F(x2) v X(~x3)))","explanation":"This is really just translation. It's a condition \"every time x1 is true\", so \"G(x1 => ... )\", and we want either x2 to eventually be true (F(x2)), or the next x3 to be false (X(~x3))."},{"studentID":"9FWl8IytHMMyyETmCpMUJijdoEj2","answer":"G(x1 -> F(x2 or X(!x3)))","explanation":"It always holds that if x1 is true then eventually x2 is true or the state after will have x3 as false."},{"studentID":"2xb6qACusvPKldc9LfV1mfG35gz1","answer":"G(x1 => F(x2) or X(!x3))","explanation":"At all times, we want x1 to imply that F(x2) and that X(X3)"},{"studentID":"79DF8m2XmUOKjV8Ob9evefRWNHw1","answer":null,"explanation":null}]},{"prompt":"If any of x1, x2, x3 is true, x4 will be true at some point of time and stay true thereafter","rationale":"it combines implication and how \"eventually\" works","answers":[{"studentID":"LKGb8fPfkfZIpgmptBwJeE7DlWm2","answer":"x1 or x2 or x3 => F(x4 and G(x4))","explanation":"i think the eventually statemnet is saying that once x4 becomes true than it will always stay true, but not sure if that's how wrapping a  G inside of an F works"},{"studentID":"UKl2qkKWlKO6BQ9PwxsbdegpkDV2","answer":"w ⊨ (x1 ∨ x2 ∨ x3) ⟹ F(G(x4))","explanation":"To get any of x1, x2, or x3 to be true, we say x1 ∨ x2 ∨ x3. This should imply that eventually x4 will be true and remain true. So there will be some point from which x4 is always true, which means \"eventually x4 is always true.\" G(x4) tells us that x4 is true in all states after and including the current one, and F(G(x4)) tells us that there is some state for which that will be true, so overall we have w ⊨ (x1 ∨ x2 ∨ x3) ⟹ F(G(x4))."},{"studentID":"0YnVb35gVyZjh40kz442E1Z1mli1","answer":"(x1 | x2 | x3) -> G(x4)","explanation":"Because one of the x1,x2,x3 be true, it will be true"},{"studentID":"Urx7swvwyjUNbQ9lD233ds11JKJ3","answer":"x1 or x2 or x3 => F(x4)","explanation":"stay true thereafter means eventually "},{"studentID":"ehCdx7swHhPf72JGATgbRZ2e7rs1","answer":null,"explanation":null},{"studentID":"M513vZuSvAWfeOE0WZ7NWBieayn1","answer":"(x1 or x2 or x3) -> F(G(x4))","explanation":""}]},{"prompt":"x2 and x3 will become true on the same step\nx1 will become true the step after x2 becomes true \nx4 will be true until x1 is true \nx2 will be true at some point","rationale":"I thought the interdependence of variables was interesting - how variables interact with each other in ways that change other variables!","answers":[{"studentID":"mkSbSzp0rUQ30XSeUq1F4HqG0S82","answer":"(!x2 || !x3) => (X(x2) <=> X(x3))\nX(x2) => X(X(x1))\nx4 U x1\nF(x2)","explanation":"if x2 or x3 are false, one becomes true in the next step if and only if the other one does as well.\nx2 true in the next step implies x1 is true in the next step's next step.\nx4 is true until x1 is.\nx2 occurs finally."},{"studentID":"LKGb8fPfkfZIpgmptBwJeE7DlWm2","answer":null,"explanation":null},{"studentID":"AxWttnGXbFOGMdMAoOcSQHoPFuB2","answer":"F(x2 and x3) and (x2 => X(x1)) and (x1 => !x4) and F(x2)","explanation":"Again, I wasn't sure if the middle implies statements should be contained in their own F statements."},{"studentID":"DqLJt0Zj9WSlYXNbRSWqy1aCnyf2","answer":"(!(x2 or x3 or x1) U (x2 and x3 and !x1 and X(x1))) and (x4 U x1)","explanation":"Assuming that \"become true\" means that the given variable is false prior to the referred state where it becomes true, and that it is not required for variables to \"stay true\" once they become true (?), this LTL formula is composed of two larger subformulas connected by \"and\":\n- The first statement enforces that neither x2, x3, or x1 are true until some state where x2 and x3 are true, x1 is false, and the next state sets x1 to true\n- x4 is  true until a state where x1 is true"}]},{"prompt":"One interesting use of LTL is too represent the sending and receiving of signals:  that is, that given a request signal x1, the grant signal x2 should eventually be asserted.","rationale":"I think this is an interesting formula because it really shows how useful LTL can be in terms of showing cause/effect relations, especially when it comes to concepts that are important in the real world.","answers":[{"studentID":"rx7fWLw9Uag06VhtzwrPHdWEKuC2","answer":"x1 -> F(x2)","explanation":"when x1 holds as true, x2 eventually (F) will be true"},{"studentID":"VcwHvUABF3hqOeJni9XH0HFRNwJ2","answer":"G(x1 => F(Xx2))","explanation":"Using always to express that the condition x1 => F(x2) that if x1 is true, meaning that the signal has been received then x2 will be true is some state following that one."},{"studentID":"Q6pogKCIaSh3uEueQnutSSKaDw33","answer":"X1->F(X2)","explanation":"If X1 is true in the first state of the trace (eg. the request signal has been sent), eventually the grant signal, X2, will happen"},{"studentID":"OorJbOFV8odzg7bElwAX7qMXKeu2","answer":null,"explanation":null},{"studentID":"XXDQ67q4UiSR2kFxVzhaxL1hRZC3","answer":"G(x1=>F(x2))","explanation":""},{"studentID":"YZmWKZlgaZOrzGYNRp4TUVv5pZ13","answer":"G(x1) U F(x2)","explanation":"This is a fairly simple sequence of states: first, the x1 signal remains \"on\", until, finally, x2 turns \"on\" (becomes true). "},{"studentID":"YzyRkeE37AhpGTSNU8zVMBwEojl1","answer":"x1 -> F(x2)","explanation":"x1 implies that x2 eventually will happen"},{"studentID":"UJYax3ztBqcD2acHhEY8qP4lBhG3","answer":"G(x1 U F(x2))","explanation":"I'm assuming x2 can be true in the same state"},{"studentID":"mhnr5IV9YdS7voOl3kwhPQJ3bcn1","answer":"(x1 => F(x2))","explanation":"The prompt doesnt ensure that x1 is true, but when it is, the x2 signal is eventually implied by x1's status\n"},{"studentID":"da61uKxwS4RS8uLw9e5aDhx9AAG2","answer":null,"explanation":null},{"studentID":"yqAbP1hwmpWXnQQRHWGW0uOlRPB3","answer":"x1 => F(x2)","explanation":"the reception is signal x1 implies that x2 will eventually be true"},{"studentID":"g189tDKZqyfaI2GiXyXWcUWilJB2","answer":null,"explanation":null},{"studentID":"FK5jY3NfsvSIHK38KFpV6g8dFak1","answer":null,"explanation":null},{"studentID":"AxWttnGXbFOGMdMAoOcSQHoPFuB2","answer":null,"explanation":null},{"studentID":"ZdXWZhb3FQamAIjPsR8DFsmHhwe2","answer":"x1 -> F(x2)","explanation":"If x1 is true, then x2 will eventually be true. Not sure about the request and grant signal"},{"studentID":"rsp3YalY4iYInzJzXy67djOCMdz2","answer":"x1 => F(x2)","explanation":"x1 implies eventually x2"},{"studentID":"5IPmn9xCANgNuM7LIh9zG4wqqQc2","answer":"x1 => F(x2)","explanation":"I think this means that if x1 is true, then x2 will eventually be true. This can be written as x1 => F(x2), since x1 is implying that x2 is eventually (or finally) true with the F operator."},{"studentID":"kOYh8lB1WQhEgx5Pte67U4XSnE93","answer":"x1 implies F(x2)","explanation":"If x1 is true, (the request signal), then x2 (the grant signal) , will be eventually true (thus using F)."},{"studentID":"phrbqZWVjcRh1ZJhWZHdh1yEhMZ2","answer":"G(x1 => F(x2))","explanation":"x1 => F(x2) means that if x1 is true, x2 should eventually be true. This should always happen"},{"studentID":"n6X9W01WPlSOMef0b3WU2WBmqVC2","answer":"x1 -> F(x2)","explanation":"if x1 is happens, x2 will eventually be happened"},{"studentID":"Mvw9fmUXFgVJjg6w1CCDcTkBdJo2","answer":"x1 -> F(x2)","explanation":"This is saying that x1 being true implies that eventually, x2 is true"}]},{"prompt":"The pattern of true and false of x1 in the first 10 entries repeats.","rationale":"This question was really challenging for me because I didn't know how to express a pattern of true false values without writing out all the possibilities. So I thought it'd be interesting to know what it would look like with higher degrees like 10 where possible patterns couldn't be exhausted easily. ","answers":[]},{"prompt":"x1 is always true and x2 is false for at least the first two time steps.","rationale":"x2 must be false for the current step and for the next step, but after that it can be anything, and x1 must be always true, which would be something like G(x1) /\\ ~x2 /\\ X(~x2).","answers":[{"studentID":"VXpluGJOfOUe37IfyjNfFz3GymV2","answer":"G(x1 AND (X!x2 AND XX!x2))","explanation":""},{"studentID":"06qfdQBcQyMQkXqkqBmyYkv99ns2","answer":null,"explanation":null},{"studentID":"kd663bJTz0hO7SfexfzikeYZgj53","answer":"XX(x1 /\\ ~x2)","explanation":"The internet says I can use X twice to signify the first two states"}]},{"prompt":"There are three people running a relay race. Person x1 will go first, then eventually person x2 will go, then finally x3 will go until the end of the race. Only one person is running in the relay race at once. ","rationale":"I think this is interesting because it is a real world application of a linear trace. I also think it is interesting because it makes use of common LTL semantics like eventually \"F( )\"","answers":[{"studentID":"yLK6W8nyVrMUkNMyxFYLNsJdaPt2","answer":"((x1 and !x2 and !x3) -> (!x1 and x2 and !x3) -> (!x1 and !x2 and x3))","explanation":"Since only one person can be running the race, this means that only one of the variables can be true, which is what I expressed in the expressions like (x1 and !x2 and !x3). Then since we know the order that they are running and -> means then, I just put the expression where x1 was true first and then used the arrow to point to the expression where x2 is true and then another arrow to point to the expression where x3 is true. "},{"studentID":"Z8I0Gua8DxZT3Lr3BGcIfZxlivI2","answer":"(x1 -> (!x2 and !x3)) -> X(x2 -> (!x1 and !x3)) -> X(X(x3 -> (!x1and !x2)))","explanation":"Basically I explicitly state how the first state of x1 being true implies that x2 and x3 are both not running, which implies how in the next state that x2 running implies that x1 and x3 are not running, and that implies that in the x2 state that x3 running implies that x1 and x2 are not running. "},{"studentID":"j2h7kE6TUTe8mOHJ8n2gWkGvi922","answer":"x1 and !x2 and !x3 and X(!x1) and X(x2) and X(!x3) and X(X( G(x3) )) and X(X( G(!x1) )) and X(X( G(!x2) ))","explanation":"The first three are making sure x1 is true at the first time step and x2 and x3 are false. The second three are making sure that only x2 is true at the second time step. The last three are saying that after the first two time steps, x3 is always true and x1 and x2 are both always false"},{"studentID":"xnwt9vlgrKQMCMF8UkHGCLYNOxw2","answer":"(x1 -> F(x2) -> F(x3)) AND ((x1 AND (not x2) AND (not x3)) OR (((not x1) AND (x2) AND (not x3)) OR (((not x1) AND (not x2) AND (x3)))","explanation":"(x1 -> F(x2) -> F(x3))  indicates that when x1 holds, then eventually x2 holds. Furthermore, when x2 holds, then eventually x3 would hold. This statement is ANDed with ((x1 AND (not x2) AND (not x3)) OR (((not x1) AND (x2) AND (not x3)) OR (((not x1) AND (not x2) AND (x3))) which attempts to show that only one person is running in the relay at once."},{"studentID":"2uAPcLiTl6S6lkVxb49jwVczlXD2","answer":"((x1 ∧ ¬x2 ∧ ¬x3) U (¬x1 ∧ x2 ∧ ¬x3)) ∧  ((¬x1 ∧ x2 ∧ ¬x3) U (¬x1 ∧ ¬x2 ∧ x3)) ","explanation":"We start with some state where only x1 is true until only x2 is true, then we have some state where only x2 is true until only x3 is true"},{"studentID":"ehCdx7swHhPf72JGATgbRZ2e7rs1","answer":"(x1 U F(x2)) U f(x3) and !(x1^x2^x3)","explanation":"F means eventually and U means after. no intersection among x1, x2 and x3."},{"studentID":"g189tDKZqyfaI2GiXyXWcUWilJB2","answer":"x1 U (x2 U x3)","explanation":"A person's variable is true if they are currently running and false otherwise. Thus, we use the \"until\" operator U to designate that different people run during disjoint sections of the trace. Specifically, \"x2 U x3\" says that x2 is running (is true) up to some state i, and x3 is running for all subsequent states after i. Similarly, x1 U (x2 U x3) says that x1 is running up to some state i, and the rest of the relay race (involving x2 and x3) occurs in the states after state i. Thus only one person is running at a time, and all eventually run in the trace."},{"studentID":"k6kvJj5VCUPWLj2ppeOMNVBQzeJ2","answer":"x1 and F(x2) and F(G(x3)) and G(!(x1 and x2) and !(x2 and x3) and !(x3 and x1) and (x1 or x2 or x3))","explanation":"\"x1\" says x1 goes first. F(x2) checks that x2 eventually goes. F(G(x3)) checks that eventually always x3 will go. the next part says that no overlap occurs"},{"studentID":"DziAzopaJDV4Nz8ugZowMZyrf2l2","answer":"F(x3 U x2 U x1) ∧ G((x1 ∧ !x2 ∧ !x3 ) ∨ (!x1 ∧ x2 ∧ !x3 ) ∨ (!x1 ∧ !x2 ∧ x3 ))","explanation":"eventually, x3 holds until x2, and x2 holds until x1. Also, there's always only on holds in x1, x2, x3"},{"studentID":"7YpZ1Wx49VhhkqMHvH1TZC9HKEz1","answer":null,"explanation":null},{"studentID":"Q6pogKCIaSh3uEueQnutSSKaDw33","answer":"(x1 /\\ ~x2 /\\ ~x3) -> F(~x1 /\\ x2 /\\ ~x3) -> F(~x1 /\\ ~x2 /\\ x3)","explanation":"The first state where only x1 is running implies an eventual state where only x2 is running, which implies an eventual state where only x3 is running"},{"studentID":"Wy5fyfEMa6cPDN3JzFAmXgbXvaw2","answer":"x1 U x2 U x3","explanation":"x1 is true until x2 is true, which in turn will be true until x3 becomes true. I do not believe the desired formula can be expressed using LTL, but this is an attempt"},{"studentID":"da61uKxwS4RS8uLw9e5aDhx9AAG2","answer":"x1 U x2 U Gx3","explanation":"we know that x1 is true first, so x1 should be true until x2 goes.  Then, x2 should be true, until final x3 goes, and x3 should be going until the end (G)"},{"studentID":"uhSgQJpSx7dbcXRJqnQpLJPHK8s1","answer":null,"explanation":null},{"studentID":"5IPmn9xCANgNuM7LIh9zG4wqqQc2","answer":null,"explanation":null},{"studentID":"eaIqaTs5sLTe88iSf2SdfYFDqPs2","answer":"(x1 and !x2 and !x3) U x2) and X(!x1 and x2 and !x3) U x3) and X(X(!x1 and !x2 and x3))","explanation":"Assuming running the race means the variable is true"},{"studentID":"QNFbaiaIhcRfRQoHtE9QvXtkhxf1","answer":"x1 !x2 !x3 and X!x1 Xx2 X!x3 and XX!x1 XX!x2 XXx3","explanation":"Define running as being true. Only one x is true at any step. At step 0 only x1 is true (meaning x1 is running) and the next are false, in the next step x2 is true and the others are false, and in the next step x3 is true and the others are false."}]},{"prompt":"X1 one is sometimes true until X2 is true and must be false after (x1)","rationale":"F(x1) U x2 -> G(!x1) I think this one is interesting because you need to use all the temporal symbols and  makes you think about how to properly use them.","answers":[{"studentID":"WLnzJgg9usPE4u8WLnHafylGsSq1","answer":"(F(x1) U (x2 /\\ G(~x1))","explanation":"x1 is sometimes true (with the F predicate) until x2 is true, and x1 is never true again."},{"studentID":"Wy5fyfEMa6cPDN3JzFAmXgbXvaw2","answer":"(x1 U x2) and G(x2 -> (!x1))","explanation":"a U b interpreted as \"a must be true until b becomes true and we do not care about a's state after b becomes true\". I do not think 'sometimes' can be expressed in LTL though."},{"studentID":"5IPmn9xCANgNuM7LIh9zG4wqqQc2","answer":"(x1 U x2) and G(x1 => X(!x1))","explanation":"I'm not really sure about the concept of \"sometimes\" here, but I decided to represent the first part as x1 U x2 (i.e. x1 is true until x2 is true. The second half seems to be saying that x1 must be false after x1 is true, so I wrote that as G(x1 = X(!x1)) i.e. if x1 is true then it will be false in the next state."},{"studentID":"9FWl8IytHMMyyETmCpMUJijdoEj2","answer":"x2 -> X(G(!x1)","explanation":"if x2 is true then in the next state x1 is false. (IDK how to express sometimes true, I thought we couldn't do that in LTL)"},{"studentID":"p81246jCdnf8jPP6ckaxgaA9ceB3","answer":"F(x2) => X(-x1)*","explanation":"My answer assumes that a trace can be defined where x1 is not true prior to x2 being true.  However if x2 is true eventually, x1 must be false for all after time steps."},{"studentID":"VcwHvUABF3hqOeJni9XH0HFRNwJ2","answer":"( F(x1)  and (x1 U x2 ) and (x1 U x1)  )","explanation":"F(x1) encodes that x1 must sometimes be true and x1Ux2 encodes that x1 can only be true until x2 is true and x1Ux1 encodes that x1 is not true after x1"},{"studentID":"SX5qjuY4LhdUlbePO48FvB797G53","answer":"(-G(x1) U x2 ) and (x2 => G(-x1)) and F(x1)","explanation":"Before x2 is true,  x1 cannot always be true (sometimes true). Once x2 is true, x1 will always be false. Thus, x1 will eventually be true before x2 is true."}]},{"prompt":"it is always true that x1 is true until x2 is eventually False","rationale":"I personally found 'until' and 'eventually' to be a concept that I often confuse\nand I only learn to use U for until, not F only halfway through the quiz so by putting this question here\nI'm hoping that it would help other students avoid this confusion. ","answers":[{"studentID":"obb14y1buwOu9DPHwVn15COD5Ky1","answer":"G(x1 U F(~x2))","explanation":"it is always true that x1 is true until x2 is eventually False\nit is always true that x1 is true until (  F(~x2) )\nit is always true that (x1 U F(~x2) )\nG(x1 U F(~x2))"},{"studentID":"WAQ3dKACLtX8yKwCEVHHryA0JWz1","answer":"x1 U !x2","explanation":"The eventually is throwing me off because until something is eventually true is kinda bad reasoning because if its eventually true in the future then its eventually true now, so I interpreted it like there was nothing there. This means that x2 is false in the future and until then x1 is true"},{"studentID":"rx7fWLw9Uag06VhtzwrPHdWEKuC2","answer":"G(x1 U F(!x2))","explanation":"The whole clause is wrapped by G (always), and U denotes until and F shows that x2 is eventually false (using !)"}]},{"prompt":"When x1, it cannot become x2 immediately or become x3 in less than 3 steps.","rationale":"It's a chronological ordering which is challenging to solve and complicated in terms of two different periods of looping.","answers":[{"studentID":"5oLl7ZPijNYyMSwp55PwKSehzRq1","answer":"(x1 /\\ ~x2 /\\ ~x3) /\\ X(~x2) /\\ X(~x3) /\\ X(X(~x3))","explanation":"if x1 is true, then it can't become x2 in the next step or become x3 in any of the next 2 steps. Becoming x2 or becoming x3 implies that x2 and x3 are currently false, and then could change to true at some point, so x2 must be false for at least step 0 and 1, and x3 must be false for at least step 0, 1, and 2."},{"studentID":"FedMWmwEd7W3C68gTqm66aRiqns2","answer":"x1 -> !x2 -> !x3","explanation":"I struggled this question, this is my best answer I don't know how to approach it further."},{"studentID":"oHfP2KoEE8PHFh9JpFBlrT9FonJ2","answer":"G(x1 => X(!x2) and XX(!x3) )","explanation":"It is always true that when it is x1, x2 has to be false for the next and x3 has to be false for the two next."},{"studentID":"phrbqZWVjcRh1ZJhWZHdh1yEhMZ2","answer":"x1 => (X(!x2)  and X(!x3) and X(X(!x3)))","explanation":"X(!x2) : means that x2 cannot be true immediately\nX(!x3) and X(X(!x3)) : means that x3 cannot be true in the next two states (so it cannot be true in less than 3 steps)"},{"studentID":"79DF8m2XmUOKjV8Ob9evefRWNHw1","answer":null,"explanation":null},{"studentID":"TWeauYjl4mWo4O6eKbArWZz1s4s1","answer":"x1 -> !(x2 or XX(x3))","explanation":"X is true in the next step, so less than 3 is XX"}]},{"prompt":"if x1 is true at the beginning then x2 is true at the end","rationale":"I think this is interesting for two reasons. 1: what it means for x1 to be true at the beginning is a little ambiguous and 2: what is means for x2 to be true at the end is also ambiguous","answers":[{"studentID":"k6kvJj5VCUPWLj2ppeOMNVBQzeJ2","answer":"x1 -> F(G(x2))","explanation":"I am trying to check if x1 is true at the beginning by using \"x1\" alone. Then, I am checking that x2 is true at the end by seeing if x2 is eventually always true."},{"studentID":"QNFbaiaIhcRfRQoHtE9QvXtkhxf1","answer":"x2 |= ! if x1 ∧ F(!x1)","explanation":"X2 becomes false if the condition on the right of the satisfiability symbol is satisfied, which is that eventually (or at the end) x1 is false."},{"studentID":"0HC3dpmLyKeoD74DguNF8DNwqrj1","answer":"x1 => F(x2)","explanation":"x1 holding true implies that eventually x2 is true. x1 on its own means x1 in the first state."},{"studentID":"n6X9W01WPlSOMef0b3WU2WBmqVC2","answer":"-","explanation":"-"},{"studentID":"yqAbP1hwmpWXnQQRHWGW0uOlRPB3","answer":null,"explanation":null},{"studentID":"WLnzJgg9usPE4u8WLnHafylGsSq1","answer":"(x1 /\\ Fx2) \\/ ~x1","explanation":"x1 is true and eventually x2 is true or x1 is not true."},{"studentID":"TWeauYjl4mWo4O6eKbArWZz1s4s1","answer":"x1 -> F(x2)","explanation":"F means it will eventually be true"},{"studentID":"Iwmu1MjrCwcLIRbtZ2likbd2krr2","answer":null,"explanation":null},{"studentID":"Q6pogKCIaSh3uEueQnutSSKaDw33","answer":"x1 -> F(G(x2))","explanation":"the \"end\" is just a state of stability, so if x1 starts as true it implies that eventually the trace is such that x2 is always true"},{"studentID":"3C5iQZrpLIPHa4l0KSVRUYUAeYn2","answer":"~x1 v F(x2)","explanation":"just x1 means x1(0) is true, which is x1 is true ath the beginning\nF(x2) means eventually true, which is the closest we can get to 'true at the end' since LTL is an infinite sequence that does not really have an end\n'if then' is equivalent to implies ->\nso we have\nx1 -> F(x2)\nbut LTL does not have implies so we will use a logically equivalent statement in place which is\np->q   <=> ~p v q"},{"studentID":"FedMWmwEd7W3C68gTqm66aRiqns2","answer":"F(x1 -> x2)","explanation":"if x1 is true then x2 is true eventually"},{"studentID":"p81246jCdnf8jPP6ckaxgaA9ceB3","answer":"x1 => F(X(x2)*)","explanation":"If x1 is true for the first time, then there will be a point where x2 is just true forever."},{"studentID":"Wy5fyfEMa6cPDN3JzFAmXgbXvaw2","answer":"x1 -> F(x2)","explanation":"\"x2 is true at the end\" interpreted as \"x2 will be true from a point on\""},{"studentID":"UKl2qkKWlKO6BQ9PwxsbdegpkDV2","answer":null,"explanation":null},{"studentID":"DqLJt0Zj9WSlYXNbRSWqy1aCnyf2","answer":null,"explanation":null},{"studentID":"2xb6qACusvPKldc9LfV1mfG35gz1","answer":"x1 and F(x2)","explanation":"bare variables apply at the beginning, F says that x2 will be true at the end"}]},{"prompt":"x1 starts true, and then never again becomes true. ","rationale":"x1 and G(X(!x1)). I think this is interesting because it leads to unreachability back to the true condition.","answers":[{"studentID":"DqLJt0Zj9WSlYXNbRSWqy1aCnyf2","answer":"x1 and X(G(!x1))","explanation":"We use the bare literal x1 to enforce that x1 \"starts true\" (which is taken to mean that the first state of the trace sets x1 as true), and then use the \"X\" formula to select the subtrace excluding the \"now\" state with the nested \"G\" function to select all states of that subtrace to set x1 to false for all states after the first."},{"studentID":"2uAPcLiTl6S6lkVxb49jwVczlXD2","answer":"x1 ∧ G(N(¬x1))","explanation":"Once we truncate off the first term, it is always true that x1 is false. "},{"studentID":"FK5jY3NfsvSIHK38KFpV6g8dFak1","answer":"x1 ^ XG ~x1","explanation":"x1 starts true=> x1\nx1 never again becomes true => G ~x1 for next step after t=0 => XG ~x1"},{"studentID":"FedMWmwEd7W3C68gTqm66aRiqns2","answer":"F(x1 -> !x1)","explanation":"Eventually, x1 becomes false forever"},{"studentID":"Mvw9fmUXFgVJjg6w1CCDcTkBdJo2","answer":"x1 -> G(X(!x1))","explanation":"x1 being true at the first step implies that the subsequent path always has x as false in the next step?"},{"studentID":"OorJbOFV8odzg7bElwAX7qMXKeu2","answer":"x1, G(X(not x1))","explanation":"x1 means that it starts true, and then we say that globally the next state would be not x1"},{"studentID":"1PfpKQ5FbSaFVpjLU0zEvi2Vsni2","answer":"x1 and X(G(not x1))","explanation":"This means that x1 is true and in the next state x1 is not true forever"},{"studentID":"da61uKxwS4RS8uLw9e5aDhx9AAG2","answer":"x1 -> G NOT x1","explanation":"x1 is true implies that NOT x1 should be true for all subsequent states"},{"studentID":"XsaC3AijqlTPGgknfTWr9Czhwed2","answer":"x1(-x1)^(omega)","explanation":"This describes a trace where x1 is true, then x1 is false \"(-x1)\" is always true (represented by \"^(omega)\")"},{"studentID":"rkJV8Z8X1ENdbW3Sk2dTT0GsMmn1","answer":"x1 X (G ¬x1)","explanation":"x1 is true in the first state, and starting in the next state, it is always not true."},{"studentID":"fRdxvbOnDTSVL5Ps9hTMqWSV5gc2","answer":"x1 U F(G(!x1))","explanation":"x1 means x1 starts true. U means it eventually stops being true and becomes false. F(G()) means that it is eventually always false."},{"studentID":"ZdXWZhb3FQamAIjPsR8DFsmHhwe2","answer":"x1 ^ G(X-x1)","explanation":"I believe this says that x1 is true and it is always true that the next state of x1 is false"},{"studentID":"eaIqaTs5sLTe88iSf2SdfYFDqPs2","answer":"x1 and G(X(!x1))","explanation":""},{"studentID":"Iwmu1MjrCwcLIRbtZ2likbd2krr2","answer":"G(X(x1))","explanation":"The answer means X(x1) must be true always. We also know that each state status x1 could be present as its precedent state's X(x1) besides the initial state. "},{"studentID":"LKGb8fPfkfZIpgmptBwJeE7DlWm2","answer":"x1 and X(!x1)","explanation":"x1 indicates x1 is true in the current time step, X(!x1) indicates x1 is false in all timesteps follwoing"},{"studentID":"1utNHrKBy7T4nb34YbOeaMGFzxl1","answer":"x1 AND G(X(!x1))","explanation":"The start value of x1 is the same as when the next time x1 is never true."},{"studentID":"uhSgQJpSx7dbcXRJqnQpLJPHK8s1","answer":"x1:=true -> F( G(x1:=false) )","explanation":"x1 is true means that eventually and always that x1 will be false."},{"studentID":"g189tDKZqyfaI2GiXyXWcUWilJB2","answer":"x1 && (X G ~x1)","explanation":"We require both that 1) x1 is true in the first state and 2) starting from the next state (X), ~x1 is true for all states (G)."},{"studentID":"R94tBoHz8ySNViJBvSke3qpd7N03","answer":"x1 and X(G(!x1))","explanation":"The first part is initially true. X shift by one and then G(!x1) is always false."}]},{"prompt":"x1 is true exactly twice","rationale":"Since LTL deals with infinite sequences, restricting a specific number of a specific type of entry (of variables being a certain value) seems to be pretty difficult","answers":[{"studentID":"g189tDKZqyfaI2GiXyXWcUWilJB2","answer":"~x1 U (x1 && X ((x1 && X G ~x1) || (~x1 U (x1 && X G ~x1))))","explanation":"We essentially need to enforce that the set of states is partitioned into to 5 sets of states: a set where ~x1 holds, a single state where x1 holds, an optionally empty set where ~x1 holds, a single state where x1 holds, and the remainder of the trace where ~x1 holds. We constrain the first set with ~x1 U (...), then designate the first single state where x1 holds with (x1 && X (...)), where the ... here enforces that x1 is true exactly once in that (remaining) state trace. Note that the single state where x1 is true can occur either as the first state or in some later state, so we split into two ORed conditions: 1) (x1 && X G ~x1) states that the state right after the previous state where x1 was true has x1 true as well, following by ~x1 holding for all future states. 2) (~x1 U (x1 && X G ~x1)) states that there is a non-zero length region where ~x1 holds, followed by a region holding to the same formula as in 1), describing a single state where x1 holds followed by ~x1 holding in all future states. Note eventually does not help us in this case because it makes no guarantee that the state chosen is the _first_ state that satisfies the predicate following the eventually."},{"studentID":"WAQ3dKACLtX8yKwCEVHHryA0JWz1","answer":"F(x1 and F(x1 and G(!x1)))","explanation":"F(x1 and ...) means eventually true that x1 is true and ... is true. F(x1 and G(!x1)) means that it is eventually true that x1 is true and x1 is false thereafter. So eventually x1 is true and then at some point in the future x1 is true again and it is false following the second true. I don't think that this is correct because there could be 3 x1 truth values and the eventually would skip over it, but I don't know a better way to approach this problem"},{"studentID":"Q6pogKCIaSh3uEueQnutSSKaDw33","answer":"F(x1 -> F(x1 -> X(G(~x1))))","explanation":"Eventually it will be true that x1 is true once, and then eventually true again, and then false forever"},{"studentID":"kd663bJTz0hO7SfexfzikeYZgj53","answer":"~x1 M (F ((x1 /\\ ~Xx1) /\\ F(x1 /\\ ~Xx1) /\\ ) ) \nG ~x1","explanation":"x1 not true until it's true once and then not true and true once then not true then it's not true"},{"studentID":"kOYh8lB1WQhEgx5Pte67U4XSnE93","answer":"x1 and (X!x1 => F( x1) or Xx1 => G(X !x1))","explanation":"This one, I am certain isn't completely right but I can discuss a bit of my thought process. What I'm saying is that x1 is true at some point, and and then after, it's either in the next state, x1 will be false, which means x1 will eventually be true at some point. On the other hand, there is the case that the next state x1 will be true, which means every state after should indicate that x1 is false. I think my issue is with the phrase X!x1 => F( x1), which isn't exactly getting to what we want in regards to \"exactly true twice\", because this could have x2 occur multiple times? But I wasn't sure exactly how to constrain it beyond that."},{"studentID":"YzyRkeE37AhpGTSNU8zVMBwEojl1","answer":"X(!x1 U x1)","explanation":"The ith x1 (from U function) and i+1st x1 will be true (X function)"},{"studentID":"k6kvJj5VCUPWLj2ppeOMNVBQzeJ2","answer":null,"explanation":null},{"studentID":"n6X9W01WPlSOMef0b3WU2WBmqVC2","answer":"x1 -> (F(x1) U G(¬x1))","explanation":"search until found the first x1 that is true then x1 will be true until after that x1 will always be false"},{"studentID":"j2h7kE6TUTe8mOHJ8n2gWkGvi922","answer":"I am not sure how to express this","explanation":"I am not sure how to express this because I am not sure how to count the number of times a variable is true in a trace in ltl"},{"studentID":"UJYax3ztBqcD2acHhEY8qP4lBhG3","answer":"F(x1 and X(F(x1 and X(G(!x1)))))","explanation":"Once x1 is true, in the rest of the states, once x1 is true again, in all the rest of those states x1 is not true"},{"studentID":"0YnVb35gVyZjh40kz442E1Z1mli1","answer":"x1 & Xx1 & !XXx1","explanation":"the first time is true, the second time is true, the third time is false"},{"studentID":"YZmWKZlgaZOrzGYNRp4TUVv5pZ13","answer":"G(not(x1)) U x1 U G(not(x1)) U x1 U G(not(x1))","explanation":"I used a series of \"until\" statements to separate the trace into moments when x1 is true and x1 is not true. I think that using x1 without the \"G\"/global describes only one state, whereas global describes a potentially longer sequence of states."}]},{"prompt":"whenever x1 is true, exactly one of x2 and x3 is false","rationale":"I think representing the if/then is interesting, especially if we didn't use =>","answers":[]},{"prompt":"x1 eventually occurs at intervals according to the Fibonacci sequence.","rationale":"I'm not sure this is even possible. You might need to refer to some other variable or past states. ","answers":[]},{"prompt":"Call x1 the variable of, did I take my medicine? I try to always take my medicine on time, but sometimes I forget. However, I never forget more than once in a row.","rationale":"A real world situation that can be pared down in LTL by thinking in terms of what it is not. Rather than focusing on the fact that you try to \"always\" take your medicine, you can capture it arguably better by saying, if I forget, then I definitely took it the next time... and LTL logic should fill in the blanks accordingly.","answers":[{"studentID":"AxWttnGXbFOGMdMAoOcSQHoPFuB2","answer":"G(x1 => X(X(x1))","explanation":"This is an awesome one! The never would mean it holds true for any length of sequence or subtrace, and the implies guarantees that, even if the next is true, there is no gap of more than two."},{"studentID":"DqLJt0Zj9WSlYXNbRSWqy1aCnyf2","answer":"G(!x1 => X(x1))","explanation":"Assuming that \"x1\" represents the proposition \"I took my medicine on time\", this trace can be simplified to \"if I forgot my medicine, I will not forget my medicine the next day\". Thus, we use \"!x1 => X(x1)\" to state that if a state sets x1 to be false, the next state in the trace must set x1 to be true, and use the \"G\" formula to enforce that this will always hold."},{"studentID":"LKGb8fPfkfZIpgmptBwJeE7DlWm2","answer":"G(!x1=> X(x1))","explanation":"globally (so it's always true for any state) , if the current state is i forgot to take my medicine then at the next timestep, i will take my medicine ( i am not super sure this is how G and X can work but it seems tofit?) "},{"studentID":"VXpluGJOfOUe37IfyjNfFz3GymV2","answer":"G(Fx1 AND (X!x1 -> XXx1))","explanation":""}]},{"prompt":"There are 2 clients who perform read/write on the same file. Only one client can write at a time and while writing no one can read the file. x1 is true if client 1 is writing, x2 is true if client 2 is writing, x3 is true is true if client 1 is reading, x4 is true if client 2 is reading.","rationale":"This formula represent a real-life problem of preserving consistency of a file with concurrent reads and writes. The traces  would reflect how transactions might be performed in a way that prevents read/write and write/write conflicts.","answers":[{"studentID":"YZmWKZlgaZOrzGYNRp4TUVv5pZ13","answer":"(c1_writing => x1) and (c2_writing => x2) and (c1_reading=>x3) and (c2_reading=>x4) and not(x1 and x2) and not(x2 and x3) and not(x3 and x4) and not (x4 and x1) and not(x2 and x4)","explanation":"I'm unsure here because the question doesn't seem to imply a temporal sequence of states, i.e, whether reading or writing happen before or after one another. I tried to express the idea of mutually exclusive states with a series of and..not statements that show that none of the states x1 ...x4 can happen at the same time."},{"studentID":"OorJbOFV8odzg7bElwAX7qMXKeu2","answer":"not G(x1 and x2)","explanation":"The problem does not mention if both clients can read at the same time. "},{"studentID":"qMF6ehxbIhSGK4673vpXIDWqRk92","answer":"(x1 U x2) or (x1 U x3) or  ( x1 U x4) or (x2 U x3) or (x2 U x4) or (x3 U x4)","explanation":"try to get two variables being true at one time. "},{"studentID":"o4OspE6hSFUWj93icU8e3H220fm1","answer":"G((w1 => x1) and (w2 =>x2) and (r1 => x3) and (r2 => x4))","explanation":"Here I represent the different conditionals with implies, where w1/w2 represents writing, and r1/r2 represents writing"},{"studentID":"XsaC3AijqlTPGgknfTWr9Czhwed2","answer":"(x1<-> -x3 AND -x4 AND -x2) AND  (x2<-> -x1 AND -x3 AND -x4) AND (x3 <-> -x1 AND -x2) AND (x4<-> -x1 AND -x2)","explanation":"Someone is writing (x1 or x2) iff \"<->\" the other person is not writing and no one is reading. Someone is reading (x3 or x4) if no one is writing \"-x1 AND -x2\""},{"studentID":"eaIqaTs5sLTe88iSf2SdfYFDqPs2","answer":"G(((x1 and !x2) or (!x1 and x2) or (!x1 and !x2)) and ((x1 or x2) => (!x3 and !x4)))","explanation":""},{"studentID":"ZdXWZhb3FQamAIjPsR8DFsmHhwe2","answer":null,"explanation":null},{"studentID":"da61uKxwS4RS8uLw9e5aDhx9AAG2","answer":"((x1) U (x2) U (x3) U (x4)) (all possible permutations of this)","explanation":"Since only one client can write/read at a time, it makes sense to use the until operator.  I did not know how to express the fact that there are many different orders in which reading/writing could happen, but essentially only one would happen at a time because of the until operator."},{"studentID":"LAeoyaF0twbF0V1g5eQ2GEPsxJE2","answer":"G((~x1 \\/ ~x2) /\\ (~x1 \\/ ~x3) /\\ (~x2 \\/ ~x4))","explanation":"The first clause is the writing constraint. The last two are the reading constraints."},{"studentID":"VXpluGJOfOUe37IfyjNfFz3GymV2","answer":"G(x1 -> !(x2 AND x4) AND x4 -> !(x1 AND x3) )","explanation":""},{"studentID":"2xb6qACusvPKldc9LfV1mfG35gz1","answer":null,"explanation":null},{"studentID":"0HC3dpmLyKeoD74DguNF8DNwqrj1","answer":"G(x1 => (!x2, !x3, !x4) AND x2 => (!x1, !x2, !x3) AND (x4 or x3) U (x1 or x2))","explanation":"If either client 1 or client 2 is writing, it will always hold that the opposite client is writing and neither of them should be reading. It also always holds that if either client is reading, then either client 1 or client 2 has written before."},{"studentID":"mkSbSzp0rUQ30XSeUq1F4HqG0S82","answer":"!(x1 && x2), (x1) => (!x3 && !x4 && !x2), (x2) => (!x3 && !x4 && !x1)","explanation":"It's not true that both are writing at the same time. If the first person is writing, that's the only thing happening. If the second person is writing, that's the only thing happening."},{"studentID":"uhSgQJpSx7dbcXRJqnQpLJPHK8s1","answer":"(x1:=true -> x2: false ^ x3:= false ^ x4:= false)^(x2:=true -> x1:=false ^ x3:= false ^ x4:=false)","explanation":"Since x1 and x2 are writing permissions, if any one of the client writes it implies that no one can read and the other client cannot write. "},{"studentID":"rsp3YalY4iYInzJzXy67djOCMdz2","answer":"G(x1 or x2 => !x3 and !x4) and G(x1 => !x2) and G(x2 => !x1)","explanation":"If either person is writing, no one can read, and if one person is writing, the other cannot write"},{"studentID":"YzyRkeE37AhpGTSNU8zVMBwEojl1","answer":"x1 or x2 -> !x3 and !x4\nx1 -> !x2\nx2 -> !x1","explanation":"Honestly, not really sure how to do this one using the LTL functions, this makes sense but does not fully utilize LTL"},{"studentID":"Iwmu1MjrCwcLIRbtZ2likbd2krr2","answer":"G((x1->(¬x2∧¬x3∧¬x4))∧(x1->¬x2∧¬x3∧¬x4))","explanation":"The system wants to make sure the safety of global writing properties. Actually reading behavior does not actively affect writing. However, when someone is writing, no one could read or write such a file besides the writing person. "},{"studentID":"EbUb3Z6acpajSNs7t62nSh5UpGi2","answer":"(x1 => !x4) AND (x2 => !x3)","explanation":"Client 1 writing implies that client 2 is not reading; client 2 writing implies that client 1 is not reading. Beyond those scopes, we do not mind what happens, so we do not have to specify anything more."},{"studentID":"rkJV8Z8X1ENdbW3Sk2dTT0GsMmn1","answer":"G((x1 ∧ ¬x2 ∧ ¬x3 ∧ ¬x4) ∨ (x2 ∧ ¬x1 ∧ ¬x3 ∧ ¬x4) ∨ (x3 ∧ ¬x1 ∧ ¬x2 ∧ ¬x4) ∨ (x4 ∧ ¬x1 ∧ ¬x2 ∧ ¬x3) ∨ (x3 ∧ x4 ∧ ¬x1 ∧ ¬x2))","explanation":"It is always the case that either one person is writing, one person is reading, or two people are reading."},{"studentID":"fRdxvbOnDTSVL5Ps9hTMqWSV5gc2","answer":"(w1 -> x1 and w2 -> x2 and r1 -> x3 and r2 -> x4) and G(x1->!x2 and x2->!x1) and G((x1 or x2)->(!x3 and !x4))","explanation":"w1 means client1 is writing, r1 means client2 is reading, etc. It is always true that if one client is writing, the other client must not be writing, which is: G(x1->!x2 and x2->!x1). It is also always true that if either client is writing, neither can read: ((x1 or x2)->(!x3 and !x4))."}]},{"prompt":"It always holds that after x1 is true, x2 will be true. X3 will not be true until both x1 and x2 are true.","rationale":"I think this is interesting because the formula should use G, X, and U. ","answers":[{"studentID":"kOYh8lB1WQhEgx5Pte67U4XSnE93","answer":null,"explanation":null},{"studentID":"Iwmu1MjrCwcLIRbtZ2likbd2krr2","answer":"F(x1->x2)∧ ((¬x3)U(x1∧x2))","explanation":"I am a little confused about this. I guess it means we have to follow two conditions: one is that after some states, if x1 is true then x2 will be true. The second part is that x3 would not be true until both x1 and x2 are true. "},{"studentID":"p81246jCdnf8jPP6ckaxgaA9ceB3","answer":"(F(x1) => X(x2)*) /\\ F(x3) => F(x1 /\\ x2)                                                                                                                                      ","explanation":"My answer uses an implication to address the first part of conjunction by defining that if x1 is eventually true then for all following time steps , x2 will hold.  The second part of the conjunction states that if x3 is eventually true, then it must hold that x1 and x2 were true for a time step prior to the time step x3 was true."},{"studentID":"M513vZuSvAWfeOE0WZ7NWBieayn1","answer":"G(x1 -> G(x2)) and (!x3 U (x1 and x2))","explanation":""},{"studentID":"LKGb8fPfkfZIpgmptBwJeE7DlWm2","answer":"G(x1 => X(x2)) and G((x1 and x2) U x3)","explanation":"it is always true that x1 being true leads to x2 being true and it is always true that x1 and x2 have to be true until x3 is true (also maybe this could be written X(x3) => x1 and x2, i wasn't sure"},{"studentID":"VcwHvUABF3hqOeJni9XH0HFRNwJ2","answer":"G(  (x1 => X(x2))  and  (not x3 U (x1 and x2)) )","explanation":"x1 implies that after one transition x2 will be true is expressed in (x1 => Xx2)  and then I use not x3 until x1 and x2 to express the second half and then use the G symbol to encode that it always holds for all states."},{"studentID":"0YnVb35gVyZjh40kz442E1Z1mli1","answer":"G(x2 U x1 and !x3 U (x1 and x2))","explanation":"G set up the always state, and U means until"}]},{"prompt":"x1 will never be true or it'll keep being true, at least occasionally, forever","rationale":"This can be written as a single expression (`always (x1 => eventually (x1))`) which actually covers both cases of the \"or\".","answers":[{"studentID":"Wy5fyfEMa6cPDN3JzFAmXgbXvaw2","answer":"(!x1) or F(x1)","explanation":"\"it'll keep being true, at least occasionally, forever\" interpreted as \"x1 will eventually become true\""},{"studentID":"Q6pogKCIaSh3uEueQnutSSKaDw33","answer":"G(~x1) \\/ G(F(x1))","explanation":"x1 is either globally always false or will always eventually be true (which I think describes the cyclical nature of the statement correctly, that it will continue to eventually be true?)"},{"studentID":"SX5qjuY4LhdUlbePO48FvB797G53","answer":"G(-x1) or G(F(x1))","explanation":"x1 is always false or x1 is always eventually true."},{"studentID":"j2h7kE6TUTe8mOHJ8n2gWkGvi922","answer":"G(!x1) or G(F(x1))","explanation":"G(!x1) means that x1 is never true, G(F(x1)) means that it always holds that x1 is eventually true"},{"studentID":"p81246jCdnf8jPP6ckaxgaA9ceB3","answer":"F(x1) => X(x1)*","explanation":"I initially used G to represent the first part of the disjunction that establishes x1 will never be true but instead used an implication to claim that if x1 is true eventually then it will be true forever after that.  This allows for traces where x1 is never true to be defined with this LTL."},{"studentID":"5oLl7ZPijNYyMSwp55PwKSehzRq1","answer":"G(~x1) \\/ G(F(x1))","explanation":"Either x1 is false globally or x1 it is always the case that x1 is true sometimes, or true eventually."},{"studentID":"oHfP2KoEE8PHFh9JpFBlrT9FonJ2","answer":"G(!x1) or G(x1)","explanation":"its either always true or false"},{"studentID":"9FWl8IytHMMyyETmCpMUJijdoEj2","answer":"G(!x1) or G(F(x1))","explanation":"Either x1 is globally false or x1 is eventually true forever"},{"studentID":"QNFbaiaIhcRfRQoHtE9QvXtkhxf1","answer":"G(!x1) OR G(F(x1))","explanation":"G means always, so the first condition in the OR formula says that x1 will be always be false (or will never be true). The second means that it is always true that x1 will be eventually true."},{"studentID":"M513vZuSvAWfeOE0WZ7NWBieayn1","answer":"G(!x1) or F(x1)","explanation":"maybe could also have just said, !G(x1)"},{"studentID":"AxWttnGXbFOGMdMAoOcSQHoPFuB2","answer":"G(!x1) or G(x1) ","explanation":"This should capture both outcomes, conveniently divided by the or."},{"studentID":"YzyRkeE37AhpGTSNU8zVMBwEojl1","answer":"G(!x1) or F(!x1 U x1)","explanation":"G function would be the case that x1 never true, I think that the f function guarantees that there will always be a future occurrence where x1 switches from false to true"},{"studentID":"yavIxXSH3vfpUlXFgyEZ39leNop2","answer":"G(!x1) or F(x1)","explanation":"never be true: G(!x1) \noccasionally true: F(x1)"}]},{"prompt":"x1 repeated flips truth values (goes from true to false and back again forever)","rationale":"I think that this function utilizes the U function in a clever way, and that piece needs to be combined to account for the fact that it flips forever","answers":[{"studentID":"yqAbP1hwmpWXnQQRHWGW0uOlRPB3","answer":"G(x1 => X(!x1) and !x1 => X(x1))","explanation":"It is always true that x1 is true implies x1 is false next, and x1 is false implies x1 is true next."},{"studentID":"1PfpKQ5FbSaFVpjLU0zEvi2Vsni2","answer":"G(x1 and X(not x1))","explanation":"This flips the truth values of x1 but assumes that the value of x1 starts as true."},{"studentID":"obb14y1buwOu9DPHwVn15COD5Ky1","answer":"G(x1 => ~X(x1) /\\ ~x1 => X(x1))","explanation":"If x1 is true in the current state, then it must be false in the next state and if x1 is false in the current state then it must be true in the next state."},{"studentID":"k6kvJj5VCUPWLj2ppeOMNVBQzeJ2","answer":"G(x1 -> X(!x)) and G(!x1 -> X(x1))","explanation":"I am using G to say this always holds. I am using X to get the trace starting at the next step (after x1 is true or false)"},{"studentID":"Z8I0Gua8DxZT3Lr3BGcIfZxlivI2","answer":"G( (x1) => X(!x1)  and !x1 => X(x1) )","explanation":"Here to create the alternating effect I made it so that is x1 is true then it implies that it's next is false, and if x1 is false it implies that it's next is true, always"},{"studentID":"7YpZ1Wx49VhhkqMHvH1TZC9HKEz1","answer":"G(((not x1) v Xx1) ^ (x1 v not Xx1))","explanation":"Globally it must be true that if x1 is true, then x1 is false in the next state, and if x1 is false, x1 is true in the next state."}]},{"prompt":"if  (x1 and x2) is eventually true, then x1 is false until it is true. Otherwise, if x2 is eventually true, then x1 is also eventually true. ","rationale":"I think that this is an interesting formula because even it includes different cases for x1 and x2 being eventually true. If they are both eventually true at the same time, this is a different case than if just x2 is eventually true ( and x1 is also true but not at the same time as x2)","answers":[{"studentID":"uq5XAODUszU4PMKhfbmC0y7kdlO2","answer":"(F(x1 and x2) => (!x1 U x1)) or ((!(F(x1 and x2) and F(x2)) => F(x1))","explanation":"I'm not quite sure how to do if/else in LTL, but the idea is to have the first statement, or'd with the second statement and the negation of the first statement."},{"studentID":"2uAPcLiTl6S6lkVxb49jwVczlXD2","answer":"(F(x1 ∧ x2) ∧ G(¬x1 U x1)) ∨ (F(x2) ∧ F(x1))","explanation":""},{"studentID":"DziAzopaJDV4Nz8ugZowMZyrf2l2","answer":"(F(x1 & x2) -> !x1 U (x1 & x2)) & (!F(x1 & x2) -> (Fx2 -> Fx1)) ","explanation":"if  (x1 & x2) is eventually true, then x1 is false until (x1 & x2) is true; if  (x1 & x2) is not eventually true, then x2 is eventually true can imply x1 is eventually true. "},{"studentID":"Olm3iZ1G75hC3g8kxg51POXFM402","answer":"(F(x1 & x2) -> (!x1 U x2)) | (!F(x1 & x2) -> F(x2) -> F(x1))","explanation":"Give the x1 and x2's final condition and imply other conditions"},{"studentID":"obb14y1buwOu9DPHwVn15COD5Ky1","answer":"(F(x1 /\\ x2) => (~x1 U (x1 /\\ x2)) /\\ ( (~F(x1 /\\ x2) /\\ F(x2)) => F(x1)) ","explanation":"(F(x1 /\\ x2) => (~x1 U (x1 /\\ x2)) = if (x1 and x2) is eventually true then x1 is false until both x1 and x2 are true\n( (~F(x1 /\\ x2) /\\ F(x2)) => F(x1)) = if (x1 and x2) is not eventually true and x2 is eventually true, then x1 is eventually true "},{"studentID":"DqLJt0Zj9WSlYXNbRSWqy1aCnyf2","answer":"F(x1 and x2) => F(x1) and !F(x1 and x2) => (F(x2) => F(x1))","explanation":"We use the \"F\" formula to find a trace where \"x1 and x2\" is eventually true, and since x1 is always false or true, we can simplify \"x1 is false until it is true\" to \"x1 is eventually true\", or \"F(x1)\". Then, to translate \"otherwise\", we build another conditional that uses the inverse of \"F(x1 and x2)\", and state that this condition implies that \"if x2 is eventually true, then x1 is eventually true\", or \"F(x2) => F(x1)\"."},{"studentID":"kExUsPs90Caj3ooAw3UTw6JiTYU2","answer":"(F(x1 and x2) => (!x1 => X(!x1)) and (x1 => X(x1))) or (F(x2) => F(x1))","explanation":"One point of confusion here for me was \" x1 is false until it is true\". That doesn't necessarily mean that x1 is not true, so I tried to reflect that."}]},{"prompt":"x1 is true at some point and x2 is always false","rationale":"This is a question that Tim thought would be interesting.","answers":[{"studentID":"R94tBoHz8ySNViJBvSke3qpd7N03","answer":"F(x1) and G(!x2)","explanation":"Direct translation."},{"studentID":"CUpKAZiiOrMlB7VEhcBrcxBDduN2","answer":"F(x1) ^ G(!x2)","explanation":"x1 is eventually (F) true, and x2 is  always (G) false (!)"},{"studentID":"obb14y1buwOu9DPHwVn15COD5Ky1","answer":"F(x1) ^ G(~x2)","explanation":"x1 true at some point = There exists a state where x1 is true = F(x1)\nx2 always false => not (x2) always true = not (x2) is true in every state"},{"studentID":"da61uKxwS4RS8uLw9e5aDhx9AAG2","answer":"Fx1 AND (G NOT x2)","explanation":"x1 must eventually be true and n2 is never true"},{"studentID":"LKGb8fPfkfZIpgmptBwJeE7DlWm2","answer":"F(x1) and G(!x2)","explanation":"eventually x1 is true. globally x2 is false"},{"studentID":"xnwt9vlgrKQMCMF8UkHGCLYNOxw2","answer":"F(x1 |= true) AND G(x2 |= false)","explanation":"F indicates eventually and |= means is. Therefore, F(x1 |= true) means that x1 is eventually true. This part of the statement is AND with G(x2 |= false) where G means always. Therefore, it is always true, that x2 is (|=) false."},{"studentID":"rkJV8Z8X1ENdbW3Sk2dTT0GsMmn1","answer":"(F x1) ∧ (G ¬x2)","explanation":"F x1 means x1 is eventually true, intersected with the traces where (G ¬x2), which means x2 is always false."},{"studentID":"SXuWPt2DVGRMnfN2ELdVux2pv9j2","answer":null,"explanation":null},{"studentID":"lRaLOybCkkdkd88UUN9jWGgL9fB3","answer":"F(x1) and G(!x2)","explanation":"At some point = F, always = G"},{"studentID":"zKquIv2iqOPUbju84kD6x2oqxQC3","answer":"F(x1) and G(!x2)","explanation":"F = (eventually), so F(x1) means that x1 is eventually true. G = (always), so G(!x2) means that x2 is always false"},{"studentID":"yLK6W8nyVrMUkNMyxFYLNsJdaPt2","answer":"F(x1) and G(!x2)","explanation":"F means that the expressions eventually holds and since the x1 is at some point true I put x1 inside of F. Since G means that the expression always holds and x2 is always supposed to be false, I put !x2 inside of G. "},{"studentID":"j2h7kE6TUTe8mOHJ8n2gWkGvi922","answer":"F(x1) and G(!x2)","explanation":"F(x1) means that x1 is true somewhere in the trace and G(!x2) means that x2 is always false"},{"studentID":"u5LtkhMrVVVNvSHlNyzDQIjuWQl2","answer":"x1 and G(!x2)","explanation":"The first part describes x1 holds.\nThe second part describes !x2 holds globally in the future."},{"studentID":"T4nr7nKQtkexYyVAi3NwCSqKC5n2","answer":"F(x1) ^ G(not x2)","explanation":"two separate propositions joined together with and"},{"studentID":"YZmWKZlgaZOrzGYNRp4TUVv5pZ13","answer":"F(x1) AND G(not(x2))","explanation":"F means finally, or eventually; basically just that, at some point in time in the future, x1 must be true. G means globally."},{"studentID":"FRxTfpBnCXSBY762KVw7F5DTJ0r1","answer":"G(!x2 and F(x1))","explanation":"x2 is always false and x1 is always eventually true"},{"studentID":"XXDQ67q4UiSR2kFxVzhaxL1hRZC3","answer":" ¬G(¬x1) ∧ G(¬x2)","explanation":"\"x1 is true at some point\" is equivalent to \"x1 is not always false\""},{"studentID":"Wy5fyfEMa6cPDN3JzFAmXgbXvaw2","answer":"(!x2) and F(x1)","explanation":"\"x1 is true at some point\" interpreted as \"x1 will eventually become and remain true (F(x1))\" and F(x1) interpreted as \"x1 at some point will become true and will remain true for the rest of the sequence\", and not as \"x1 will eventually be true, but may become false again after that\""},{"studentID":"AAzmbLYzxbcuw8WEJsNweNOfr542","answer":"Fx1 AND G(NOT x2)","explanation":"Eventually x1 is true AND globally x2 is not true"},{"studentID":"3C5iQZrpLIPHa4l0KSVRUYUAeYn2","answer":null,"explanation":null},{"studentID":"5IPmn9xCANgNuM7LIh9zG4wqqQc2","answer":"F(x1) and G(!x2)","explanation":"If x1 is true at some point then we should use the F operator to indicate \"eventually\" (i.e. x1 is eventually true). If x2 is always false then we use the G operator to indicate that it's global. Therefore F(x1) and G(!x2)."},{"studentID":"eaIqaTs5sLTe88iSf2SdfYFDqPs2","answer":"F(x1) and G(!x2)","explanation":""},{"studentID":"QNFbaiaIhcRfRQoHtE9QvXtkhxf1","answer":"F(x1) and G(!x2)","explanation":"F means eventually, or at \"some point\", and G means always. ! means false."},{"studentID":"o4OspE6hSFUWj93icU8e3H220fm1","answer":"G(!x2) and F(x1)","explanation":"This formula technically satisfies the text, but if they mean that at some point there exist a state where x1 is true, I don't think this can be written in LTL since it is an example of an availability property."},{"studentID":"XsaC3AijqlTPGgknfTWr9Czhwed2","answer":"F(x1) AND G(-x2)","explanation":"eventually x1 is true \"F(x1)\" and \"AND (using this to represent the logical and operator)\" x2 is always false \"G(-x2)\""},{"studentID":"FJ1gcCB1SMXfbX4ehcXzcYHcs7l1","answer":"F(x1) ^ G(~x2)","explanation":"We want both conditions to hold (hence ^), where one of them is x1 to be eventually true (F(x1)), and the other is x2 to always be false (G(~x2))."},{"studentID":"UJYax3ztBqcD2acHhEY8qP4lBhG3","answer":"F(x1) and G(!x2)","explanation":""}]},{"prompt":"if x2 is true and x1 is true and x3 is true, then it eventually holds that x1 and x2 and x3 are always true","rationale":"I think this is interesting because it effectively describes how a system can reach a point of convergence. ","answers":[{"studentID":"EbUb3Z6acpajSNs7t62nSh5UpGi2","answer":"(x2 and x1 and x3) => F(x1 and x3 and x3)","explanation":"Parsed it by section and translated to LTL terms."},{"studentID":"AxWttnGXbFOGMdMAoOcSQHoPFuB2","answer":"F(x2 and x1 and x3) => G(x2 and x1 and x3)","explanation":"This should only output the later part of the implies statement, or they never all evaluate to true."},{"studentID":"VcwHvUABF3hqOeJni9XH0HFRNwJ2","answer":"(x2 and x2 and x3) => F( G(x1 and x2 and x3))","explanation":"The formula is encoded with an implies statement. The first half, encodes that x1,x2 and x3 are true and the second encodes that the predicate x1 and x2 and x3 are eventually always true with the F(G(pred)) notation."},{"studentID":"obb14y1buwOu9DPHwVn15COD5Ky1","answer":"(x1 /\\ x2 /\\ x3) => F( G(x1 /\\ x2 /\\ x3))","explanation":"(x1 /\\ x2 /\\ x3) = true in current state\nF( G(x1 /\\ x2 /\\ x3)) = Eventually we will reach a point where all of the variables are true (?)\n"},{"studentID":"06qfdQBcQyMQkXqkqBmyYkv99ns2","answer":"(x2 and x1 and x3) => F(G(x1 and x2 and x3))","explanation":"(x2 and x1 and x3) is whether x2, x1, and x3 are all true.  This implies that eventually (F), it will always be the case (G) that (x1 and x2 and x3) are all true."}]},{"prompt":"x1 is true sometime after 4 or more transitions","rationale":"This is a question that Tim thought would be interesting.","answers":[{"studentID":"WLnzJgg9usPE4u8WLnHafylGsSq1","answer":"F(omega^4) |= x1","explanation":"The trace must eventually satisfy x1 after 4 or more transitions, so we apply the eventually rule to the trace starting after the fourth transition."},{"studentID":"Iwmu1MjrCwcLIRbtZ2likbd2krr2","answer":"FXXXX(x1)","explanation":"x1 is true sometime after 4 or more transitions means that there exists state S where 4 states after state S will make x1 true. "},{"studentID":"ZdXWZhb3FQamAIjPsR8DFsmHhwe2","answer":"XXXXx1 or XXXX!x1 -> F(x1)","explanation":"I was trying to portray \"4 or more transitions\", however I was unsure how to so without the variable after. \"x is true sometime after\" i interpreted as eventually"},{"studentID":"FRxTfpBnCXSBY762KVw7F5DTJ0r1","answer":"!x1 and X(!x1) and X(X(!x1)) and X(X(X(!x1))) and F(x1)","explanation":"x1 is false for the current state and the next three states, but eventually it will be true"},{"studentID":"da61uKxwS4RS8uLw9e5aDhx9AAG2","answer":"Fx1","explanation":"F represents the fact that x1 should eventually be true.  However, I do not believe there is a way to represent the x1 will be true specifically after a certain number of transitions in LTL"},{"studentID":"eaIqaTs5sLTe88iSf2SdfYFDqPs2","answer":"X(X(X(X(F(x1)))))","explanation":""},{"studentID":"qsvPOzEQ1NeTrWs1iQmcqVOTHOJ3","answer":"F(X(X(X(X(x1)))))","explanation":"X(X(X(X(x1)))) skips 4 transitions ahead, F evaluates to true sometime in the subsequence."},{"studentID":"kExUsPs90Caj3ooAw3UTw6JiTYU2","answer":"X(X(X(X(F(x1)))))","explanation":"note: I assume here that by \"transitions\" they meant state"},{"studentID":"06qfdQBcQyMQkXqkqBmyYkv99ns2","answer":"F(XXXXx1)","explanation":"There will eventually be some state such that x1 is true four states down the line.  This ensures that x1 is true in some state from four transitions onward."},{"studentID":"FK5jY3NfsvSIHK38KFpV6g8dFak1","answer":"XXXXFx1","explanation":"since W_i |= Xp mean that p is true in trace w_{i+1}, w_{i+2}, ....\nW_i |= XXXXp mean p is true in trace w_{i+4}, w_{i+5}, ....\nand W_i |= Fx1 means x1 is true for some j>=i in w_i\nTherefore,  W_i |= XXXXFx1 means x1 is true for some j>=i+4 in w_i\nwhich is exactly what the question asks for."},{"studentID":"lRaLOybCkkdkd88UUN9jWGgL9fB3","answer":"X(X(X(X(F(x1)))))","explanation":"We first chop off the first four states with X and then do a normal eventually"},{"studentID":"kOYh8lB1WQhEgx5Pte67U4XSnE93","answer":"!x1 and X!x1 and XX!!x and XXX!x1 iff  F(x1)","explanation":"I hard code out 4 states where x1 is false. If these all hold, that means that x1 can be true at some point after. I use IFF instead if implies because I wanted to specify this is the only case for F(x1). IF it were only implies, then FTFTT could be valid (each boolean is a different state of the same variable x1)"},{"studentID":"FJ1gcCB1SMXfbX4ehcXzcYHcs7l1","answer":"X(X(X(X(F(x1)))))","explanation":"If we wanted x1 to be true sometime after 0 or more transitions, this would just be F(x1). If we want to enforce a certain number of transitions, we can ignore the first n states by using X^n. So, X(X(X(X(F(x1)))) will only consider at least four transitions."},{"studentID":"yLK6W8nyVrMUkNMyxFYLNsJdaPt2","answer":"X(X(X(X(F(x1)))))","explanation":"I don't really know how to express \"four or more transitions\", but I know that X refers to the next state, so I put four Xs to represent the next next next next state and then inside of that I put F(x1) since F means that the expression will eventually or sometimes be true. "},{"studentID":"zKquIv2iqOPUbju84kD6x2oqxQC3","answer":"X(X(X(X(F(x1)))))","explanation":"x1 is eventually true after 4 states."},{"studentID":"AAzmbLYzxbcuw8WEJsNweNOfr542","answer":"F(XXXXx1)","explanation":"XXXX is after 4 iteration from the current state.\nIf you add F (eventually). Inductively, F(XXXXx1) is x1 is true after 4 or more iterations. "},{"studentID":"DziAzopaJDV4Nz8ugZowMZyrf2l2","answer":"X^4(x1) -> x1","explanation":"X^4(x1) means x1 has 4 or more transitions, the imply x1 is true"},{"studentID":"T4nr7nKQtkexYyVAi3NwCSqKC5n2","answer":"XXXX(F(x1))","explanation":"Four states later (XXXX), x1 has to be true at some point (F)"},{"studentID":"SXuWPt2DVGRMnfN2ELdVux2pv9j2","answer":"X(X(X(X(F(x1))))","explanation":"x1 is true sometime = F(x1), after 4 or more transitions = X(X(X(X(...))))"},{"studentID":"xnwt9vlgrKQMCMF8UkHGCLYNOxw2","answer":"F>=4(x1 |= true)","explanation":"F represents eventuality. I put \">=4\" to indicate the next 4 or more transitions. Hence it is eventually true that x1 is true after 4 or more transitions."},{"studentID":"VcwHvUABF3hqOeJni9XH0HFRNwJ2","answer":"XXXX(F(x1))","explanation":"The X symbol enforces that something will be satisfied after one transition, so I'm using four Xs to indicate that after four transitions eventually x1 will be true."},{"studentID":"uhSgQJpSx7dbcXRJqnQpLJPHK8s1","answer":"x1 = true -> A^=4 ","explanation":"I interpreted \"sometime\" as eventually and the A (from an online LTL syntax source) means states so I thought of specifying that there will be 4 states/transitions "},{"studentID":"2uAPcLiTl6S6lkVxb49jwVczlXD2","answer":"(¬x1)->(¬x1)->(¬x1)->(¬x1)->(¬x1)->(¬x1)->(x1)ω  ⊢ F(N(N(N(N(x1)))))","explanation":"First we truncate the trace by four transitions, then x1 will eventually be true "},{"studentID":"WAQ3dKACLtX8yKwCEVHHryA0JWz1","answer":"F(X(X(X(X(x1)))))","explanation":"F means eventually and X(X(X(X(x1)))) means 4 after the current x1 is true"},{"studentID":"R94tBoHz8ySNViJBvSke3qpd7N03","answer":"X(X(X(X(F(x1)))))","explanation":"X(X(X(X(...)))) shift by 4. F(x1) is eventually x1."},{"studentID":"QNFbaiaIhcRfRQoHtE9QvXtkhxf1","answer":"XXXXF(x1)","explanation":"X means in the next step, or transition. F means eventually. Therefore, XXXXFx1 means that in 4 iterations, x1 will eventually be true."},{"studentID":"Mvw9fmUXFgVJjg6w1CCDcTkBdJo2","answer":"F(X(X(X(x1)))","explanation":"Eventually, x1 is true in the next, next, next step. This skip of three states means that it could occur three next states after the first state, or eventually in the subsequent path after that"},{"studentID":"mhnr5IV9YdS7voOl3kwhPQJ3bcn1","answer":"(X(X(X(X(x1))) U X(X(X(X(!x1)))) => F(x1)","explanation":"whether or not x1 is true on the first 4 iterations, following this it will be true."},{"studentID":"AJhRpKsvXyRzhbZwJMshU1xBreG3","answer":"X(X(X(X(x1 or F(x1)))))","explanation":"After 4 transitions (X), either x1 is true or it will be true in the future"},{"studentID":"CUpKAZiiOrMlB7VEhcBrcxBDduN2","answer":"F(X(X(X(X(x1)))))","explanation":"Eventually (F), the fourth-next (XXXX) state of x1 becomes true"}]},{"prompt":"it is eventually true that x1 and x2 will be true if and only if x1 begins false and x2 begins true but becomes false at some point","rationale":"writing an iff requires doing two implies, which some people may find it hard to think of and the fact that x2 begins true but becomes false at some point means you have to use X in that relation as well which is tricky","answers":[]},{"prompt":"Given states x1, x2, and x3: always transitioning in a cycle (ex. x1 -> x2 -> x3 -> x1 ...)","rationale":"I think this is interesting because it enforces a pattern on the transition of the states but not necessarily an ordering (i.e. there are many ways to always cycle 3 states). I would also find it difficult to encode in LTL.","answers":[{"studentID":"phrbqZWVjcRh1ZJhWZHdh1yEhMZ2","answer":"G(((x1 and !x2 and !x3) <=> X(!x1 and x2 and !x3) <=> X(X(!x1 and !x2 and x3))) and\n((x1 and !x2 and !x3) or (!x1 and x2 and !x3) or (!x1 and !x2 and x3))","explanation":"x1 and !x2 and !x3 : means that in the current state, only x1 is true\nX(!x1 and x2 and !x3)  : means that in the next state, only x2 is true\nX(X(!x1 and !x2 and x3)) : means that in the next next state, only x3 is true\n\nthese must always be true iff the next one is the proper state. Additionally, it must be true that the state is one of these three states"},{"studentID":"mkSbSzp0rUQ30XSeUq1F4HqG0S82","answer":"x1 => X(x2 && !x1 $$ !x3)\nx2 => X(x3 && !x1 $$ !x2)\nx3 => X(x1 && !x3 $$ !x2)","explanation":"This isn't elegant, but it should encode what's described."},{"studentID":"Ao8FhZPEPeV6WdP0CYNeEiGGwP52","answer":"G( (x1 ^ X(x2)) ∨ (x2 ^ X(x3)) ∨ (x3 ^ X(x1))","explanation":"This says that it is always the cast that either x1 is true and x2 is true next, x2 is true and x3 is true next, or x3 is true and x1 is true next. This gives us the cycle that is being described. "},{"studentID":"2uAPcLiTl6S6lkVxb49jwVczlXD2","answer":"G(x1=>N(x2)=>N(N(x3)=>N(N(N(x1))))","explanation":""},{"studentID":"DziAzopaJDV4Nz8ugZowMZyrf2l2","answer":"G (x1 -> Xx2 & x2 -> Xx3 & x3 -> Xx1)","explanation":"always, x1 implies next state of x2 is true,  x2 implies next state of x3 is true,  x3 implies next state of x1 is true"},{"studentID":"SX5qjuY4LhdUlbePO48FvB797G53","answer":"Incorrectly defined.","explanation":"x1, x2, and x3 should be variables, not states. Have no way of knowing the boolean vars in each state, so cannot be encoded."},{"studentID":"rx7fWLw9Uag06VhtzwrPHdWEKuC2","answer":"(x1 -> !x2 and !x3 and X(!x1 and x2 and !x3)) and (x2 -> !x1 and !x3 and X(!x1 and !x2 and x3)) and (x3 -> !x1 and !x2 and X(x1 and !x2 and !x3))","explanation":"I decided to implement this using three main clauses, each of which says that if xi is true then the other xs are false and then in the next state xi is false and the subsequent x is true."}]},{"prompt":"x1 is true in the next state, or x1 is true in all states.","rationale":"I believe there is more than one valid answer, which raises the question of associativity, i.e. I think \"(Xx1) v (Gx1)\" is the same as \"X(x1 v G x1)\" (unless I misunderstood how \"G\" works).","answers":[{"studentID":"VcwHvUABF3hqOeJni9XH0HFRNwJ2","answer":null,"explanation":null},{"studentID":"OorJbOFV8odzg7bElwAX7qMXKeu2","answer":"x1, X(x1) or G(x1)","explanation":""}]},{"prompt":"x1 is always true until both x2 and x3 once to be true.","rationale":"It is quite easy to make mistakes take the conjunction of x2 and x3 after the \"until\" clause. However, such predicates imply that x2 and x3 must be true at the same state, which is not what we want in the English sentence. ","answers":[{"studentID":"WLnzJgg9usPE4u8WLnHafylGsSq1","answer":"G(x1) U x2 /\\ x3","explanation":"x1 is always true until x2 and x3 are true"},{"studentID":"ehCdx7swHhPf72JGATgbRZ2e7rs1","answer":"x1 U (x2 and x3)","explanation":"I guess until implies U."},{"studentID":"yavIxXSH3vfpUlXFgyEZ39leNop2","answer":"x1 U (x2 and x3)","explanation":"We can use the until operator to say that x1 is true until x2 and x3 are. "},{"studentID":"XKjYJO7zc0dP1NfMtzP4jbagTLR2","answer":"G(x1 U (F(x2) and F(x3)))","explanation":"not sure \"once\" means in this sentence; I interpreted as \"wants\""},{"studentID":"1utNHrKBy7T4nb34YbOeaMGFzxl1","answer":"G(x1) AND !G(x2 AND x3)","explanation":"Once to be true seems to translate to x2 and x3 never always being true."},{"studentID":"Q6pogKCIaSh3uEueQnutSSKaDw33","answer":"G(x1 -> (x1 \\/ (x2 /\\ x3)))","explanation":"x1 either implies more truth of x1 to follow or x1 is false in the event that both x2 and x3 are true? this was difficult for my brain"},{"studentID":"uq5XAODUszU4PMKhfbmC0y7kdlO2","answer":"G(x1 U (x2 and x3))","explanation":""},{"studentID":"0YnVb35gVyZjh40kz442E1Z1mli1","answer":"x1 U (F(x2 & x3))","explanation":"Once x2 and x3 is true, x1 is always true"}]}]